# PBS 136 of X — More Jesting

We met [Jest](https://jestjs.io/), the testing toolkit we'll be using for the JavaScript port of the Crypt::HSXKPasswd Perl module in the previous instalment. While we did use Jest, we only scratched the surface of what Jest can do. In this instalment we're not going to expand our knowledge so we have enough to get started on our project. This will not be anywhere near everything there is to know about Jest, but it will be enough for us for now.

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE IF NEEDED

* The instalment ZIP file — [pbs136.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs136.zip).

## A Quick Jest Refresher

In the previous instalment we learned that in Jest we use the `test()` function to define tests, and each of those tests contains one or more expectations, which we implement with the `expect()` function.

As a reminder of the syntax, here's an overly simplistic example:

```js
 test('JavaScript can add', ()=>{
    expect(1 + 1).toBe(2);
 });
```

## Optionally Play Along

The examples in this instalment all improve on the basic test suite we created in the previous instalment for a simple module that joins an array of strings in a human-friendly way. If you'd like to play along you can use the folder `pbs135b-joiner-after` as your starting point. Remember to run `npm ci` in the folder before you start!

The final version of the test suite is included in this instalment's ZIP file in the folder `pbs136a-joiner`, and again, remember to run `npm ci` before attempting to run the test suite.

## Grouping Tests with `.describe()`

The first thing we can do to improve our test suite is group related tests. When we left our test suite last time (`src/joiner.test.js`) the tests were interspersed with big eye-catching multi-line comments to group them visually within the code, e.g.:

```js
//
 // === Test the modifiers ===
 //

 test('ampersand modifier', ()=>{
    expect(joiner().ampersand.join(['a', 'b', 'c'])).toBe('a, b & c');
 });

 test('and modifier', ()=>{
    expect(joiner().and.join(['a', 'b', 'c'])).toBe('a, b and c');
 });

 test('or modifier', ()=>{
    expect(joiner().or.join(['a', 'b', 'c'])).toBe('a, b or c');
 });

 test('single quote modifier', ()=>{
    expect(joiner().quote.join(['a', 'b', 'c'])).toBe("'a', 'b' & 'c'");
 });

 test('double quote modifier', ()=>{
    expect(joiner().doubleQuote.join(['a', 'b', 'c'])).toBe('"a", "b" & "c"');
 });

 test('sort modifier', ()=>{
    expect(joiner().sort.join(['a', 'c', 'b'])).toBe('a, b & c');
 });
```

Rather than grouping them only visually, we should group them logically, and Jest provides that functionality through its `describe()` function. This function takes two arguments, a string with a label for the group of tests, and a function that defines the tests. The function is generally written as an arrow function, so the usual syntax looks like this:

```js
describe('JavaScript can do basic arithmetic', ()=>{
  test('JavaScript can add', ()=>{
     expect(1 + 1).toBe(2);
   });
   test('JavaScript can subract', ()=>{
     expect(2 - 1).toBe(1);
   });
   test('JavaScript can multiply', ()=>{
     expect(2 * 2).toBe(4);
   });
   test('JavaScript can divide', ()=>{
     expect(4 / 2).toBe(2);
   });
});
```

Let's update our test suite accordingly:

```js
describe('test modifiers', ()=>{
  test('ampersand modifier', ()=>{
    expect(joiner().ampersand.join(['a', 'b', 'c'])).toBe('a, b & c');
  });
  test('and modifier', ()=>{
    expect(joiner().and.join(['a', 'b', 'c'])).toBe('a, b and c');
  });
  test('or modifier', ()=>{
    expect(joiner().or.join(['a', 'b', 'c'])).toBe('a, b or c');
  });
  test('single quote modifier', ()=>{
    expect(joiner().quote.join(['a', 'b', 'c'])).toBe("'a', 'b' & 'c'");
  });
  test('double quote modifier', ()=>{
    expect(joiner().doubleQuote.join(['a', 'b', 'c'])).toBe('"a", "b" & "c"');
  });
  test('sort modifier', ()=>{
    expect(joiner().sort.join(['a', 'c', 'b'])).toBe('a, b & c');
  });
});
```

When we run our test suite Jest will label and indent this related group of tests in its output:

```text
 PASS  src/joiner.test.js
  ✓ Module exports expected value (2 ms)
  ✓ Default  Join (2 ms)
  test modifiers
    ✓ ampersand modifier
    ✓ and modifier (1 ms)
    ✓ or modifier
    ✓ single quote modifier (1 ms)
    ✓ double quote modifier
    ✓ sort modifier (1 ms)

Test Suites: 1 passed, 1 total
Tests:       8 passed, 8 total
Snapshots:   0 total
Time:        0.179 s, estimated 1 s
```

Jest allows groupings to be nested, so as your code becomes more complex, your groupings can too. You can uses nested groupings to have the structure of your tests mirror the structure of your code — e.g. a group for all the tests related to a class, and inside that, a group for all tests related to a specific function within that class.

## Repeatable Tests with `describe.each()()`

It's very common to need to repeat a test many times over with different inputs. You could duplicate your code, like we do in this overly large test in our test suite:

```js
 test('Default  Join', ()=>{
    // typical case - joins with an & when passed a regular list of strings
    expect(joiner().join(['a', 'b', 'c'])).toBe('a, b & c');

    // edge case - empty array
    expect(joiner().join([])).toBe('');

    // edge case - one string
    expect(joiner().join(['a'])).toBe('a');

    // edge case - two strings
    expect(joiner().join(['a', 'b'])).toBe('a & b');

    // invalid data - not an array
    expect(()=>{joiner().join('pancakes')}).toThrow(TypeError);
 });
```

This test was structured this way primarily as an example to show that a single test can contain multiple expectations. However, this is not a well written test, there are three things wrong with it:

1. I've been forced to describe the actual things being checked in comments because I've put too much into one test. Jest allows you to label tests and groups of tests, not individual expectations.
2. There are two separate concepts being tested in a single test — does the function work as expected when handed valid inputs, and does the function throw an error when  handed invalid input.
3. There is a lot of repetition — if you ignore the last expectation, the other four are all identical apart from the description, the inputs to the function under test (`joiner().join()`), and the expected outcome.

We can fix the first and second problems using Jest features we've already met, so let's do that first:

```js
describe('test default join (no modifiers)', ()=>{
  describe('with valid data', ()=>{
    test('typical case - joins with an & when passed a regular list of strings', ()=>{
      expect(joiner().join(['a', 'b', 'c'])).toBe('a, b & c');
    });
    test('edge case - empty array', ()=>{
      expect(joiner().join([])).toBe('');
    });
    test('edge case - one string', ()=>{
      expect(joiner().join(['a'])).toBe('a');
    });
    test('edge case - two strings', ()=>{
      expect(joiner().join(['a', 'b'])).toBe('a & b');
    });
  });
  
  test('with invalid data', ()=>{
    expect(()=>{joiner().join('pancakes')}).toThrow(TypeError);
  });
});
```

Note the nesting of the groupings — we have a `describe()` inside a `describe()`.

Before we made this change all those expectations were reported in the output as simply:

```text
 ✓ Default  Join (2 ms)
```

Now that we have added the groupings and moved each expectation into its own test we get much better output:

```js
test default join (no modifiers)
    ✓ with invalid data (2 ms)
    with valid data
      ✓ typical case - joins with an & when passed a regular list of strings
      ✓ edge case - empty array (1 ms)
      ✓ edge case - one string
      ✓ edge case - two strings (1 ms)
```

This still leaves us with a lot of repetition, but that repetition is now entirely contained within a group of tests:

```js
describe('with valid data', ()=>{
  test('typical case - joins with an & when passed a regular list of strings', ()=>{
    expect(joiner().join(['a', 'b', 'c'])).toBe('a, b & c');
  });
  test('edge case - empty array', ()=>{
    expect(joiner().join([])).toBe('');
  });
  test('edge case - one string', ()=>{
    expect(joiner().join(['a'])).toBe('a');
  });
  test('edge case - two strings', ()=>{
    expect(joiner().join(['a', 'b'])).toBe('a & b');
  });
});
```

Notice that there are only three things varying from test to test — the description, the input, and the expected output. That seems overly verbose, and annoyingly reparative to type, surely there must be a better way?

Of course there is, Jest provides a mechanism for looping over a collection of tests with variables via its `describe.each()()` function. This is a function that returns a function, so you call it with two sets of arguments — one for the `describe.each()` itself, and one for the function it returns. `describe.each` expects just a single argument, an array of arrays of values. Each inner array defines values for a desired number of variables for use within the repeated tests, and you just keep adding arrays to add more tests to the loop.

The function returned from `describe.each()` also expects two arguments, a description of the looped test that can contain place-holders for the variables, and a function that defines the tests. The function will be called with the values in the arrays, so you can name the values by naming the arguments to this function. The function is generally passed as an arrow function.

Note that the placeholders are specified using the so-called `printf` syntax from the C programming language. The substitutions start with a `%` symbol and are inserted in the order they appear in the array. You tell Jest how to convert the value to a string by changing the letter that comes after the `%`, .e.g `%s` inserts a string, `%i` an integer, and `%j` JASON representation of a complex piece of data. You'll find the full list of available placeholders in [Jest's documentation for `describe.each()()`](https://jestjs.io/docs/api#describename-fn).

This all sounds very complicated, but it makes more sense when you see it in action:

```js
describe.each([
  ['typical case - 3 arguments', ['a', 'b', 'c'], 'a, b & c'],
  ['edge case - empty array',    [],              ''        ],
  ['edge case - one string',     ['a'],           'a'       ],
  ['edge case - two strings',    ['a', 'b'],      'a & b'   ]
])('with valid data', (desc, input, result)=>{
  test(desc, ()=>{
    expect(joiner().join(input)).toBe(result);
  });
});
```

When we run our test suite we see this group as:

```text
with valid data
      ✓ typical case - 3 arguments (1 ms)
      ✓ edge case - empty array
      ✓ edge case - one string
      ✓ edge case - two strings
```

Note that each inner array contains three elements, a description, an array to use as input to the join function, and the expected output as a string.

Each array defines arguments that will be passed to the arrow function that defines the tests, so we name the values when we define that arrow function, in this case, we name the first argument `desc`, the second `input`, and the third `output`. We can then use those names when defining our test.

Note that adding an additional test is as simple as adding another inner array with the needed data.

MAYBE IF I HAVE TIME — add more failure tests

## Pre and Post-Test Hooks

TO DO

## .only and .skip

TO DO

## Final Thoughts

TO DO