# PBS 119 of X â€” Open Source on GitHub

Our stated aim from the start of our exploration of Git has been to get to a stage where we could use Git to keep our own code safe and easily accessible, effectively collaborate within a closed group, and, finally, participate in the open source community.

We're nearly there!

We have the skills to manage our own code, and we have the skills to work within a closed group. All that's left is dipping our proverbial toe into the open source waters, and that's what this instalment is all about!

You can engage at different levels, so we're going to start with the most passive, and work our way towards the ultimate goal â€” contributing to an open source project. Next time you find a silly typo in these show notes, you'll have the skills to fix it ðŸ˜‰

Like with the previous two instalments, we're going to be looking exclusively at GitHub in this instalment. Again, my reason for picking GitHub is simple, they offer a good service across a wide array of pricing tiers, their free tier is really feature-rich, they have a track record of being good netizens, and probably not unrelatedly, many open source projects are hosted there.

Other hosted Git service providers like GitLab offer very similar functionality, while the broad concepts should appear familiar, the implementation details definitely differ.

## Matching Podcast Episode

TO DO

## Reminder â€” the Open Source Community is not a Team

Before we get stuck into the details, I want to re-iterate what makes the open source community different to a team of friends or co-workers (as described in [instalment 116](pbs116)). A team is a group of equals were everyone can push commits to, and pull commits from, a shared repository. The open source community is more complex. Within a project there will be a core group of people with read and write access, the so-called *maintainers*, but many more people will want to access the code, and some will want to contribute fixes or enhancements to the code. Opening up read-access to the world is no problem, but write access? If you simply opened up your repository for anyone to push to you'd be hosting malware within minutes! Clearly, a better workflow is needed!

## Three Open Source Scenarios

We're going to look at three levels of interaction you can choose to have with an open source project hosted on GitHub:

1. You can use the code exactly as-is
2. You can use the code with a few customisations of your own
3. You can customise the code and contribute those customisations back to the project

## Scenario 1 â€” Use Code As-is (Just Clone it)

The simplest way to access open source code published on GitHub is to simply clone the repo! The URL is available right on a repository's home page, just click the **Code** button, choose your URL scheme, and paste into your favourite client or into a CLI Git command in your terminal.

There really is nothing more to it. Also, all other Git-hosting services that cater to the open source community will provide the same functionality, they'll just lay their interface out a little differently and they might use different names for the buttons.

Before moving on, I'd like to dwell on some things you may start to notice as you browse through open source repos â€” most open source projects have some kind of build process to turn the code written by the developers into the final product used by the users. As a general rule, `REAME.md` should contain build instructions if they're needed.

A common convention in repos that require building is to include completed builds in the repo in a folder named `dist` (short for *distribution*). Generally the build in `dist` is only updated in commits that get tagged as releases, and by no means all projects choose to include builds in their repos at all.

Some projects (like [jQuery](https://github.com/jquery/jquery)), provide a `dist` folder that's effectively empty until you build the code yourself using the instructions in `README.md`. Others like [Bootstrap](https://github.com/twbs/bootstrap/tree/v4-dev) do provide full builds in their `dist` folder.

## Scenario 2 â€” Use Customised Code (Fork & Pull)

## Scenario 3 â€” Contribute (Fork & Create Pull Requests)