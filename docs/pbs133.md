# PBS 133 of X — Firming up our Foundations

We're getting closer to having all our proverbial ducks in a row for starting work on the rewrite of the `Crypt::HSXKPasswd` Perl module in JavaScript. Before we could start we needed to introduce some new technologies and make some technology decisions. Here's a quick status update:

1. Introduce ES6 modules — done ✅
2. Introduce Node & NPM — done ✅
3. Choose a Linter and learn how to use it — ESLint (with thanks to guest teacher Helma van der Linden) ✅ 
4. Chose a documentation generator and learn how to use it — JSDoc with the DocDash theme ✅
5. Choose a Test Driven Development (TDD) platform and learn how to use it — work in progress (see below)
6. Choose a bundler and learn how to use it — to do

I spent my Christmas break working on the fifth point — figuring out the most appropriate TDD platform for the project. The contenders were QUnit, Mocha, Jasmin, and Jest.

I've picked Jest, but before we can learn to use it, there are some fundamental JavaScript concepts we need to refresh in our minds, and explore a little more deeply. Simultaneously, the community over on Slack have highlighted a few additional concepts that some are finding a little difficult to digest. Given those two facts, it seems sensible to dedicate this episode to a collection of refreshers, specifically:

1. Some confusion around the difference between `npm install` and `npm ci`.
2. Some confusion around JSDoc tags.
3. A refresher on some of the more esoteric aspects of functions — anonymous functions, arrow functions, and immediately-executing functions.
4. An unusual use of getter functions that's becoming popular in some modern JavaScript APIs, including Jest.

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE OR DELETE

* The instalment ZIP file — [pbs133.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs133.zip).

## A Refresher on Installing Modules with NPM

I've noticed some confusion as to what the `npm install` and `npm ci` commands actually do, and when you should use each, so let's try clarify that a little.

Firstly, let's set some context here — NPM does many things, and `package.json` can store many different types of information, but for this discussion we're only interested in installing modules into a Node project folder.

Let's start with the basics. A Node project folder is simply a folder that contains a valid `package.json` folder. When you use either the `node` or `npm` commands within a Node project folder they will interact with three key files/folders:

1. `package.json` specifies that 3rd-party modules the project depends on via the `dependencies` and `devDependencies`, and specifies acceptable version ranges for each.
2. `node_modules` is where 3rd-party modules get installed.
3. `package-lock.json` specifies the exact versions of each 3rd-party module that have been installed.

There are two distinct scenarios in which you can use a Node project folder, and it's the scenario that determines whether you need `npm ci` or `npm install`.

### Scenario 1 — Initialising a Previously Created Project for Use

In this scenario you are given a Node project folder that already contains both a `package.json` and a `package-lock.json` file, but no `node_modules` folder. Since 3rd-party modules are intended to be downloaded and installed by NPM, the `node_modules` folder should not be committed to source control, nor included in ZIP files for distribution.

**Any Node project folders included in the Instalment ZIPs in this series fall into this category, as do other people's Git repositories you clone.**

The problem to be solved here is that you want to initialise the `node_modules` folder **exactly as it was on the author's machine**. Given the fact that `package.json` defines **version ranges** for the dependencies, the same `package.json` files can produce many possible mixes of module versions, potentially leading to subtly different behaviour as different versions will have different bug fixes applied. We don't want *'a set of modules that meets the spec'*, we want the exact set the author had, i.e. we want to replicate the packages recorded in `package-lock.json`.

The `npm ci` command deletes anything that exists within the `node_modules`  folder, then reads `package-lock.json` and installs the exact versions listed into `node-modules`. I.e. it does a *clean install*, hence the command name `ci`.

In other words, **when initialising a copy of someone else's Node project, always use `npm ci`**.

### Scenario 2 — Managing Dependencies in a Node Project You Contribute To

There are four sub-scenarios here:

1. You've checked your own code out of source control on a new machine and want to pick up exactly where you left off
2. You're starting a new project
3. You want to add a new dependency to your project
4. You want to up date your existing dependencies to the latest versions that match the contents of `package.json`

The first sub-scenario is just scenario 1 really — initialising a copy of your own code to exactly where you left off is no different to initialising a copy of someone else's code exactly where they left off! So, **to pick up where you left off on your own code, also use `npm ci`.**

When you start a new project there are no dependencies, so really, the second sub-scenario is the same as the third. **To add a new dependency use `npm install --save`** (or `npm install --save-dev` for a dev dependency). This will add a new entry to `package.json` and specify the acceptable version range as *anything newer than the current version with the same major version*. (Remember, all NPM modules use [Semantic Versioning](https://semver.org)). The exact version installed will also be written to `package-lock.json`, as well as the exact version of every dependency that was installed along with the module you expressly installed.

Finally, **to roll all your dependencies forward to the latest versions allowed by the current `package.json` use `npm update`**. This will update both `package.json` to set new minimum versions, and `package-lock.json`. If you want to upgrade a dependency to a new major version you'll need to manually edit `package.json` and then run `npm update`.

## A Quick Summary of the Most Important JSDoc Tags

TO DO

## A Refresher on Functions

TO DO

## A Novel use of Getters

TO DO

## Final Thoughts

Hopefully the first two sections will help people better understand how we're using NPM, and how to document code effectively. The final two sections will help us better understand the Jest TDD API which we'll be introducing in the next instalment.