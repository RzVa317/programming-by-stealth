# PBS 144 of X â€” Basic Shell Script IO

In [the previous instalment](./pbs143) we learned how to collect terminal commands into re-usable shell scripts. Those scripts did exactly the same thing every time they were run, because they had no way of accepting any input. The obvious next step is to learn how to send information into your scripts.

There are actually three ways of passing information into scripts, and arguably three forms out output too. You can pass commandline arguments to scripts, you can prompt the user for input, your script will always finish with an exit code, and you can use unix-style pipes to redirect input to your scripts, and your scripts will produce both output and error output streams which can also be redirected. For a detailed look at what I call *terminal plumbing*, check out Taming the Terminal Instalment TO DO.

For reasons that will become obvious, we need to learn about flow of control (conditional and loops) before we can fully use the streams, so we'll actually put a pin in those until the end of our short excursion into shell scripting. In this instalment we'll learn about the other three forms of IO, specifically, we'll learn to pass arguments to our scripts, to ask the user for input, and how exit codes get generated. Exit codes are vital to understanding conditionals and loops in shell scripts, so that will tee us up perfectly for the next instalment.

## Matching Podcast Episode

TO DO

## Command line Arguments

By far the simplest way to get some data in is to accept command line arguments, i.e. space-separated strings after the name of your script.

Bash makes command line arguments available to us in our scripts through special variables, `$1` is the first argument, `$2` the second, and so on. The command used to invoke the script is available as `$0` in case you're wondering why computer scientists were counting from 1 like regular humans for once ðŸ˜‰

The script `pbs144a-args.sh` shows this in action:

```bash
#!/usr/bin/env bash

echo "I am '$0', my first arg is '$1', and my second is '$2'"
```

If we run the script with the command `./pbs144a-args.sh pancakes waffles` we get:

```
bart@bartsmacstudio pbs144 % ./pbs144a-args.sh pancakes waffles
I am './pbs144a-args.sh', my first arg is 'pancakes', and my second is 'waffles'
bart@bartsmacstudio pbs144 %
```

## Prompting the User

The Bash `read` command and read input, one line at a time, from any stream, but by default it reads it from the standard input (`STDIN`) which is the generally the keyboard (unless you're dealing with pipes, but we're ignoring that for now). We could of course print a message with `echo` telling the user what to enter, and then simply read from `STDIN`, but we don't have to use two commands to do something so commonly needed, instead, we can us the `-p` flag to specify the *prompt* the user will be given.

TO DO â€” EXAMPLE

## Exit Codes

TO DO

## Final Thoughts

TO DO
