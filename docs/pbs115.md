# PBS 115 of X — The Push & Pull of Git

TO DO

## Matching Podcast Episode

TO DO

## Instalment Resources

* The instalment ZIP file — [pbs114.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs114.zip).

## Playing Along — TO UPDATE

If you'd like to play along with the examples you'll need to download this instalment's ZIP file and unzip it. Open a terminal and change to the folder into which you extracted the ZIP . You'll find a bash script named `pbs114-init.sh` as well as a bundle file name `pbs114a.bundle`.

This script automates the steps bring us back to where we left off last time, one working repository now named `pbs114a-desktop`, and one pretend-NAS-repository now named `pbs114a-nas`. If you open the script in your favourite text editor you'll see that it does the following:

1. create a folder named `pbs114a-desktop`
2. change into that folder
3. initialise it as a Git repo
4. if needed, change the default branch from `master` to `main`
5. import all branches and tags from the bundle
6. change back to the zip folder
7. created a folder named `pbs114a-nas.git`
8. initialise `pbs114a-nas.git` as a bare Git repo
9. change into the `pbs114a-desktop` folder/repo
10. add `pbs114a-nas.git` as a remote named `origin`
11. fetch `origin` (the prentend-NAS repo)
12. push all branches to `origin`
13. push all tags to `origin`
14. change into `pbs114a-nas.git` and force it's default branch to be `main` (only needed because we're injecting content into the *bare* repository in an unusual way to stop Git being too helpful and ruining the examples)

One you have a terminal open in the folder the ZIP extracted to you're ready to run the script. We'll start by making sure the script is executable:

```
chmod 755 *.sh
```

Now we can execute it with:

```
./pbs114-init.sh
```

If you view the contents of the folder (in your file manager or on the Terminal with the `ls` command) you'll see that two new folders have been created named `pbs114a-desktop`, and `pbs114a-nas`, these are our repositories.

## Tracking Branches — An Update

To allow Git to push and pull without needing explicit branch names all the time we need to tell it which local branches match to which remote branches.

The commands to set up tracking relationships vary a little depending on your exact situation. There are three situations we'll cover:

TO DO — UPDATE THE PARAGRAPH ABOVE

1. Establishing a tracking relationship between a local and a remote branch that already exist.
2. Publishing a local branch that does not previously exist on a remote to that remote.
3. Creating a new local branch from a pre-existing remote branch. Put a pin in this scenario until later.

### Tracking a NEW Remote Branch — TO CHECK

To allow Git to push and pull without needing explicit branch names all the time we need to tell it which local branches match to which remote branches. The generic command to do this is:

```
git checkout -b LOCAL_BRANCH REMOTE/REMOTE_BRANCH
```

Where `LOCAL_BRANCH` is the name of a local branch (it can be a new branch), `REMOTE` is the name of the remote, and `REMOTE_BRANCH` is the name of the remote branch.

Note that if you choose, you can use different names for the local and remote branches. As a general rule, I advise against that, it often just leads to confusion, but there are times when that becomes useful. The only *real world* situation where I routines use different remote and local branch names is when collaboration with another person/organisation who's naming scheme is utterly different to mine/ours.

Because you almost always keep the two names the same, Git offers a convenient shortcut to help reduce repetition in commands, the `--track` flag. The following two commands mean exactly the same thing:

```
git checkout -b main origin/main
git checkout --track origin/main
```

## Auto-prune

TO DO

## Final Thoughts

TO DO