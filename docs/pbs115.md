# PBS 115 of X — The Push & Pull of Git

Starting with instalment 112 we've been discovering how Git establishes peer-to-peer relationships between repositories. We started with the theory and the jargon, then in instalment 113 we moved on to create our first relationship between repositories, and finally in instalment 114 we introduced the concept of establishing relationships between local and remote branches. Or, to use the jargon, we've learned that we establish relationships between our current repository and other repositories by adding *remotes*, and that we can configure local branches to *track* remote branches.

We learned that different Git commands are used to establish tracking relationships in different scenarios. We learned that we use `git branch -u`  to set the current local branch to track a remote branch, and that we can use `git push -u` to publish a local branch to a remote and track it. We learned that there was a third scenario, creating a tracking local branch from a remote branch that doesn't exist locally, but we didn't learn the command for dealing with that scenario. That will be the most important thing we learn in this instalment, but we'll learn it within a bigger context.

In the previous instalment we introduced the scenario of a lone developer who has a SAN for storing the authoritative copy of their repository, and working copies of the repository on their laptop and desktop computers for doing their development work. It's entirely normal and to be expected for our imagined developer to start work on one of their machines, then continue on another before switching back to the first. With tracking branches this proves very easy to do!

TO UPDATE

## Matching Podcast Episode

TO DO

## Instalment Resources

* The instalment ZIP file — [pbs115.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs115.zip).

## Playing Along

If you'd like to play along with the examples you'll need to download this instalment's ZIP file and unzip it. Open a terminal and change to the folder into which you extracted the ZIP . You'll find a bash script named `pbs115-init.sh` as well as a bundle file name `pbs115a.bundle`.

This script automates the steps bring us back to where we left off last time, two working repositories now named `pbs115a-desktop` & `pbs115a-laptop`, and one pretend-NAS-repository now named `pbs115a-nas.git`. If you open the script in your favourite text editor you'll see that it does the following:

1. clone the bundle into a new bare repository named `pbs115a-nas.git`
2. clone the new NAS repository into a regular new repository named `pbs115a-desktop`
3. clone the NAS repository again into a regular new repository named `pbs115a-laptop`

One you have a terminal open in the folder the ZIP extracted to you're ready to run the script. We'll start by making sure the script is executable:

```
chmod 755 *.sh
```

Now we can execute it with:

```
./pbs115-init.sh
```

If you view the contents of the folder (in your file manager or on the Terminal with the `ls` command) you'll see that three new folders have been created named `pbs114a-nas.git`, `pbs115a-desktop`, and `pbs114a-laptop`, these are our repositories.

## Worked Example — a new Feature Developed Across Two Computers

TO DO

### Tracking a NEW Remote Branch — TO CHECK

To allow Git to push and pull without needing explicit branch names all the time we need to tell it which local branches match to which remote branches. The generic command to do this is:

```
git checkout -b LOCAL_BRANCH REMOTE/REMOTE_BRANCH
```

Where `LOCAL_BRANCH` is the name of a local branch (it can be a new branch), `REMOTE` is the name of the remote, and `REMOTE_BRANCH` is the name of the remote branch.

Note that if you choose, you can use different names for the local and remote branches. As a general rule, I advise against that, it often just leads to confusion, but there are times when that becomes useful. The only *real world* situation where I routines use different remote and local branch names is when collaboration with another person/organisation who's naming scheme is utterly different to mine/ours.

Because you almost always keep the two names the same, Git offers a convenient shortcut to help reduce repetition in commands, the `--track` flag. The following two commands mean exactly the same thing:

```
git checkout -b main origin/main
git checkout --track origin/main
```

## Auto-prune

TO DO

## Final Thoughts

TO DO