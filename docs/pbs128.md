# PBS 128 of X — JavaScript Module Basics

The first milestone in phase 2 of this series is a port of the existing Crypt::HSXKPasswd Perl module to a JavaScript module. Since our first end-goal is a JavaScript module, it's high time we learned what JavaScript modules are!

In this series we've generally taken the approach of only learning things the current *'right way'*™️, but when needed, we've stated with a summary of the history to give us the broader context needed to make sense of why things are the way they are. For example, without understanding that HTML 5 is the intended replacement for both HTML 4 and XHTML 1 it doesn't make sense that both `<hr>` and `<hr />` are valid syntax, or even more bizarrely, that `<option selected="selected">`, `<option selected>`, and `<option selected=true>` are equivalent. If HTML 5 were being designed in a vacuum it simply wouldn't have these kinds of quirks!

On the one hand, the reason we've not covered JavaScript modules up until this point is because of the very messy history of modules in JavaScript. On the other hand, we now have a standard — sure, it's got some quirks because of that messy history, but at least it's a single, official, standard! We can now learn one approach, and use it everywhere!

## Matching Podcast Episode

TO DO

## Instalment Resources

MAYBE DELETE

* The instalment ZIP file — [pbs128.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs128.zip).

## The Problem to be Solved

We want to be able to re-use code in such a way that the internal workings of the code are entirely isolated from our code, without the possibility of any kind of *spooky action at a distance*.

If I put something into the global scope in my code, it shouldn't be possible for some third-party code I load to mess with it behind my back. Similarly, it shouldn't be possible for two pieces of third-party code to effectively fight over the use of a single global variable and break each other's functionality.

Before modules, if I named a global variable something sensible but generic like `currentBalance`, then I had trust that no third-party code I loaded used that same globally scoped variable. One side-effect of this mess is a kind of variable-name-land-war among the common libraries, with jQuery being effectively hogging the variable name `$`, and [Underscore](https://underscorejs.org/) and its competitor [loDash](https://lodash.com/) the variable name `_`.

Without modules, you have to choose — do you want to use Underscore, or do you want to use loDash? Why? Because there's only one global variable named `_`, so since both libraries write their code into that global variable, they collide — the second one loaded simply overwrites the first!

## A Potted History of Javascript Modules

### A Very Primitive First Attempt

If the biggest problem is littering the global namespace, then a good first step to a solution is to cut down on the use of the global scope. One way to do that is to utilise the fact that functions define their own scopes, and to use self-executing anonymous functions to wrap code in separate scopes, and only store the values returned by these anonymous functions in the global scope. These self-executing un-named functions are more properly known as IIFE, or [Immediately Invoked Function Expressions](https://developer.mozilla.org/en-US/docs/Glossary/IIFE). We covered them way way back in instalment X.

This is clearly hackery. It makes you code look messy, and it only addresses part of the problem — sure, it keep the the namespace cleaner, but spooky action at a distance is just as possible, and it doesn't address two libraries publishing their code into the same global variable. IIFEs do not solve the Underscore/loDash problem.

### Two 'Winners' and a Failed Unification

I like to say that the best thing about being a programmer is that you can *scratch you own itch*. Well, all JavaScript programmers are programmers, and the lack of any kind of official packaging system for JavaScript made a lot of developers very very itchy indeed!

IIFEs alone simply wouldn't cut it, they needed to be wrapped in additional functionality to provide a mechanism for re-naming variables on import, and, for allowing different code files or third party libraries to specify their interdependencies.

There were lots of early attempts at solving this problem, and it could easily have been the case that one single de-facto standard had emerged, but that's not what happened. The JavaScript community effectively broke into two camps — server-side coders, and client-side coders — and each picked their own winner. Rather than one de-facto standard, we got two!

On the browser side the open source [RequireJS](https://requirejs.org/) won out with it's AMD (Async Module Definition) format, and on the server side the [CommonJS](https://en.wikipedia.org/wiki/CommonJS) project won out when their specification was adopted by [NodeJS](https://nodejs.org/).

For code that only made sense on one side or the other, there was no problem. A library like [PopperJS](https://popper.js.org) for making fancy browser tooltips only works in a browser, so it only needs to support AMD, and similarly, a library like [fs-extra](https://www.npmjs.com/package/fs-extra) for better file system interactions only makes sense on the server-side, so it only needs to support CommonJS.

But what about libraries that are just as useful on the server and the browser, things like [MomentJS](https://momentjs.com/) for example? Well, they could bundle two variants of their code, an AMD variant and a CommonJS variant, but that's a pain in the you-know-what!

That's where UMD comes in, the very self-aggrandising *Universal Module Definition*. UMD took the best bits of AMD and CommonJS and provided a format that would work both on the server and in the browser. In fact, UMD is a bit like the wave-particle duality in physics. If you design an experiment that treats an electron as a particle it will behave like a particle, but if you design your experiment to treat those same electrons as waves, they'll behave as waves. Well, if you treat a UMD module as if it were a CommonJS module it'll work just fine, and if you treat it like an AMD module it also works just fine!

Rather than being a single standard, UMD is a kind of code-chameleon, adapting to its environment as needed.

Needless to say, this mess of competing standards put more and more pressure on the committee behind the official JavaScript specification to come up with one single official solution to the packaging problem.

### White Smoke — an Official Standard at Last!

We've finally arrived at the point where there not only is an official standard (it was released as part of ECMA 6 in 2015), but it is now widely supported on both the client and server side. All the major browser support ES6 AKA ES Harmony modules, as does the latest LTS version of NodeJS. The reason I made a big point about it being important not to be on an old version of NodeJS in the previous instalment is that older versions of NodeJS only support CommonJS modules, not ES 6 modules.

## ES 6 Modules — The Big Picture

TO DO

## Writing a Module

TO DO

## Importing a Module

TO DO

## Final Thoughts

TO DO