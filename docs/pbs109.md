# PBS 109 of X — SemVar & Structured Commits

TO DO

## Matching Podcast Episode

TO DO

## Instalment Resources

TO UPDATE IF NEEDED

* The instalment ZIP file — [pbs109.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs109.zip).

## Playing Along 

TO UPDATE IF NEEDED

If you're like to play along with the examples you'll need to download this instalment's ZIP file and unzip it. Open a terminal and change into the folder you extracted the ZIP into. You'll find a file in there named `pbs109a.bundle`, this is a bundled version of the repository we created in the previous instalment, with an additional commit added to update the references to the instalment number from 108 to 109, and with the names of the tags updated for reasons that will become obvious later.

Like we did in the previous two instalments, we need to make a new repository and import all the branches and tags from the bundle. We'll name our new repository `pbs109a`. To create this new repo we'll take the following steps:

1. create a folder named `pbs109a`
2. change into that folder
3. initialise it as a Git repo
4. if needed, change the default branch from `master` to `main`
5. import all branches and tags from the bundle into our new repository

The commands to do all this are

```
mkdir pbs109a
cd pbs109a
git init
[ `git symbolic-ref --short HEAD` = 'master' ] && git checkout -b main
git fetch --update-head-ok ../pbs109a.bundle '*:*'
git checkout main
```

Notice that the command to import from the bundle is different to the one used in previous instalments. The reason for this is that previously, we were only importing a single branch, now, we want to import everything.

## Naming Software Releases

We could probably dedicate an entire series within a series on the age-old question of how name specific releases of software. Everyone seems to be agreed that something at least partly numeric makes sense, but beyond that there seems to be very little agreement at all!

Because we generally agree that it makes sense to use numbers in our release names we tend to refer to these as *version numbers*, or *release numbers*, even if they're usually much more than just regular integer or decimal numbers. Some schemes make heavy use of English in their *'version numbers'* making use of words like *beta*, *alpha*, *stable*, *experimental*, *edge* (for *bleeding edge*), and so on. Others contain only numbers and symbols.

Fundamentally, I would argue that a good numbering system is one that's:

1. **Simple** — if you can't explain the meaning in a version number in few sentences it's unlikely your scheme is working!
2. **Consistent** — once you've picked your rules, stick to them!
3. **Meaningful** — different software projects need to communicate different types of information in their release numbers, the scheme you choose must capture the information that's meaningful to your project, and ideally avoid encoding information that's irrelevant, that's just clutter!
4. **Lexically Sortable** — this might sound silly, but it's actually very important when it comes to finding branches in a repository, files in releases folder, downloads in an automatically generated list, and so on, that alphabetic sorting yields a sensible list.

Personally, I'm drawn to the concept of reverse-date numbering where you number your software as `YYYYMMDD.R`, where `YYYY` is a four-digit year, `MM` a two digit month, `DD` a two-digit day-of-the-month, and `R` a release sequence number. It's easy, I don't have to think too hard about it, and it sorts perfectly. It contains very little information though! Is `20201227.1` a bug fix? A feature release, or a complete re-write?

### Three Types of Change

The insight at the root of the numbering system we'll be focusing on in this series is that software changes can be grouped into three categories:

1. **Fixes** — the specification remains completely un-changed, but a problem with the implementation is fixed so reality comes closer to theory. Basically, *'it should always have worked like this'*.
2. **New Features** — the specification is expanded to include something new. Nothing has been removed, the software still does everything it did previously, but now it does more. Basically *'you can keep doing what you're doing, but now you can do this too!'*
3. **Breaking Changes** — the specification has changed so that something which was once part of the specification isn't anymore. Basically, *'some of you will have to change how you do something'*

Whether you're a programmer consuming an API, or a user using an app, those three categories are equally as meaningful because they focus on the effects the change has on users. If you see that a new release contains only fixes, you know you can apply it without thinking about it. If you see that a new release has some new features it's worth your time to read the release notes to see if you can benefit from the new goodness, but you can install the update without fear of something breaking. Finally, if you see that a release contains breaking changes you know you need to read the release notes carefully to figure out how the change effects you.

Note that there's still a huge range within each category. Some bug fixes might require a complete re-write of the back-end code to the same thing in a much safer or more efficient way, or, it could be as simple as deleting a stray character in an obscure info panel or warning message. A new feature could be as simple as the option to do two things you can do already in a single action, or, the addition of an entire new set of features. Finally, a breaking change to an app could be as simple as the removal of a feature almost no one uses, or, it could be a complete re-write of the entire UI. Similarly, a breaking change to an API could be as simple as a change to the arguments to an obscure function almost no one uses, or it could be as big as the entire API switching from callbacks to promises!

### Semantic Versioning, or SemVer

An extremely popular release naming/numbering scheme is *Semantic Vesioning*, or *SemVer*. You'll find the full specification at [semver.org](https://semver.org/), but really, the spec's official summary captures the basics perfectly:

> Given a version number `MAJOR.MINOR.PATCH`, increment the:
> 
> 1. `MAJOR` version when you make incompatible API changes,
> 2. `MINOR` version when you add functionality in a backwards compatible manner, and
> 3. PATCH version when you make backwards compatible bug fixes.
>
>  Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.

Note that officially, SemVer is for naming API releases, but the principles are broad enough that they can be applied to all software IMO.

Building on the summary above, the spec also reserves the `0` major version for initial development, and as long as that initial number is zero the software should not be considered stable, and breaking changes are perfectly acceptable without incrementing the major version. The major version number `1` is reserved for the first official release of the software.

Additionally, think of the three numbers are being in a hierarchy. When you increment the major number your release can include new features and patches too, and similarly, when you increment the minor number your release can include patches too. Also note that when you increment the major version both the minor and patch versions have to go to zero, and similarly, when you increment the minor version the patch version has to go to zero. In other words `1.2.3` can only be followed by `2.0.0`, `1.3.0`, or `1.2.4`.

Visually, the spec is very clear, no leading zeros, and any of the three parts of the SemVer can expand to multiple digits as needed, `1.0.9` does not become `1.1.0` for a patch release. 

Pre-release versions can have additional information added, but the additional information should be grouped into dot-separated identifiers, and separated from the normal SemVer by a dash. E.g. `1.2.3-apha`, or even `1.2.3-beta.4`.

Finally, if your software has a complex enough build process that it makes sense to encode some metadata relating to that process into the version number, you can group it into dot-separated identifiers and append it to the end of the version number, separated from it by a plus symbol, e.g. `1.2.3+M1`, or even `1.2.3-alpha.2+202012271636.WIN64`.

In some circumstances SemVer goes beyond a convention into a requirement. A great example of this is NPM, the JavaScript package manager. All NPM package releases must be named using SemVer, and the auto-updater is aware of the three levels of change encoded into a a SemVer, and can be configured accordingly. For example, you can instruct NPM to automatically apply all patch releases, or, all patch and all feature releases, but you'll always have to explicitly request major releases.

From this point on, when ever examples in this series require release names, we'll use SemVer.

## Meaningful Commit Messages

In an ideal world, commit messages should be meaningful to both humans and computers. A person should be able to read a commit message and understand the kind of change it represents, and, any automations in your project's software toolkit should be able to understand the commit messages too.

### Conventional Commits

To make this possible, a nice simple standard has been proposed — [Conventional Commits](https://www.conventionalcommits.org/).

The name can be a little confusing, but I think of it as *a convention for structuring commit messages*.

The basic structure of a conventional commit is very simple:

```
TYPE: DESCRIPTION

BODY

FOOTERS 
```

The `TYPE` is either `fix` for a change that maps to a SemVar patch, `feat` for a change that adds a new feature, i.e. a SemVar minor version, and other commits can have descriptive `TYPE`s like `wip`, `docs`, or `test`.

The `DESCRIPTION` is mandatory and should be a one-line summary of the change.

The `BODY` is optional, can consist of multiple paragraphs, and can be in Markdown.

The `FOOTERS` are optional, and consist of name-value pairs separated by either a colon and a space, or a space and an octothorp (`#`). The names must be alpha numeric, and spaces should be replaced with dashes. You're generally free to invent your own footers, but there is one specially defined footer name, `BREAKING-CHANGE`. Just to add a little confusion, the spec defines one exception to the rule that footer names can't contain spaces, the name `BREAKING CHANGE` can be used instead of `BREAKING-CHANGE`.

If your project is big enough you can optionally add a *scope* to the `TYPE` by appending it wrapped in parentheses, e.g. `fix(ui)`.

You might expect that since `fix` and `feat` map nicely to SemVar, there would be a similar `TYPE` for breaking changes, but there isn't. Instead, breaking changes are indicated either by adding an exclamation point to the end of the `TYPE` and describing them breakage in the `DESCRIPTION`, and/or, by adding a `BREAKING-CHANGE` footer that describes the breakage.

This sounds more complicated than it really is — a few examples should make things clear:

#### Work-in-progress Commits

```
wip: made a start on the new boogers() function
```

```
wip continued boogers() function

Added comments with the pseudo-code for the algorithm.
```

```
docs: documented the boogers() function
```

```
test: added unit tests for the boogers() function
```

#### Fix Commits

```
fix: stopped boogers() from throwing an error every second Tuesday
```

```
fix: upgraded dependencies to apply security fixes

Upgraded the following dependencies:
* `SomeLib` to 3.7.2
*  `SomeOtherLib` to 6.5.4.
```

#### Feature Commits (Breaking & Non-Breaking)

```
feat: added snot() function
```

```
feat: expanded add() function

The add() function originally only supported two arguments, now, any number of arguments can be passed, and the function will add them all together.
```

```
refactor!: changed add() function arguments

The add() function now requires the numbers to be added be passed as a single array.

BREAKING-CHANGE: add(number, number, ...) replaced with add(array)
```

## Example — Multiple Development Branches with SemVar & Conventional Commits

TO DO

## Final Thoughts

TO DO