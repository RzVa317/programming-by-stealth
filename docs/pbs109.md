# PBS 109 of X — SemVar & Structured Commits

TO DO

## Matching Podcast Episode

TO DO

## Instalment Resources

TO UPDATE IF NEEDED

* The instalment ZIP file — [pbs109.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs109.zip).

## Playing Along 

TO UPDATE IF NEEDED

If you're like to play along with the examples you'll need to download this instalment's ZIP file and unzip it. Open a terminal and change into the folder you extracted the ZIP into. You'll find a file in there named `pbs108a.bundle`, this is a bundled version of the repository we created in the previous instalment, with an additional commit added to update the references to the instalment number from 107 to 108.

Like we did in the previous two instalments, we need to make a new repository and import the `main` branch from the bundle. We'll name our new repository `pbs108a`. To create this new repo we'll take the following steps:

1. create a folder named `pbs108a`
2. change into that folder
3. initialise it as a Git repo
4. if needed, change the default branch from `master` to `main`
5. import the `main` branch from the bundle into our new repository

The commands to do all this are

```
mkdir pbs108a
cd pbs108a
git init
[ `git symbolic-ref --short HEAD` = 'master' ] && git checkout -b main
git pull ../pbs108a.bundle
```

## Semantic Versioning AKA *SemVar*

We could probably dedicate an entire series within a series on the age-old question of how name software versions. Everyone seems to be agreed that something at least partly numeric makes sense, but beyond that there seems to be very little agreement at all!

Some schemes make heavy use of English in their *'version numbers'* with phrases like *beta*, *alpha*, *stable*, *experimental*, *edge* (for *bleeding edge*), and so on. Others contain only numbers and some symbols.

Fundamentally, I would argue that a good numbering system is one that meets these goals:

1. **Simple** — if you can't explain the meaning in a version number in few sentences it's unlikely your scheme is working!
2. **Consistent** — once you've picked your rules, stick to them!
3. **Meaningful** — different software projects need to communicate different types of information in their release numbers, the scheme you choose must capture the information that's meaningful to your project, and ideally avoid encoding information that's irrelevant, that's just clutter!
4. **Lexically Sortable** — this might sound silly, but it's actually very important when it comes to finding branches in a repository, files in releases folder, downloads in an automatically generated list, and so on, that alphabetic sorting yields a sensible list.

Personally, I'm drawn to the concept of reverse-date numbering where you number your software as `YYYYMMDD.R`, where `YYYY` is a four-digit year, `MM` a two digit month, `DD` a two-digit day-of-the-month, and `R` a release sequence number. It's easy, I don't have to think too hard about it, and it sorts perfectly. It contains very little information though! Is `20201227.1` a bug fix? A feature release, or a complete re-write?

## Structured Commits

TO DO

## Final Thoughts

TO DO