# PBS 116 of X — Git with a Friends

TO DO

## Matching Podcast Episode

TO DO

## Instalment Resources — PROBABLY DELETE

* The instalment ZIP file — [pbs116.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs116.zip).

## Playing Along — PROBABLY DELETE

If you'd like to play along with the examples you'll need to download this instalment's ZIP file and unzip it. Open a terminal and change to the folder into which you extracted the ZIP . You'll find a bash script named `pbs115-init.sh` as well as a bundle file name `pbs115a.bundle`.

This script automates the steps bring us back to where we left off last time, two working repositories now named `pbs115a-desktop` & `pbs115a-laptop`, and one pretend-NAS-repository now named `pbs115a-nas.git`. If you open the script in your favourite text editor you'll see that it does the following:

1. clone the bundle into a new bare repository named `pbs115a-nas.git`
2. clone the new NAS repository into a regular new repository named `pbs115a-desktop`
3. clone the NAS repository again into a regular new repository named `pbs115a-laptop`

One you have a terminal open in the folder the ZIP extracted to you're ready to run the script. We'll start by making sure the script is executable:

```
chmod 755 *.sh
```

Now we can execute it with:

```
./pbs115-init.sh
```

If you view the contents of the folder (in your file manager or on the Terminal with the `ls` command) you'll see that three new folders have been created named `pbs114a-nas.git`, `pbs115a-desktop`, and `pbs114a-laptop`, these are our repositories.

## Fetch -v-  Pull

Before we look at working with Git as part of a team, I want to take a moment to underline the difference between fetching and pulling.

Remember that Git keeps a local cache of all defined remotes. Fetching is simply the act of updating that local cache. No changes are merged into any of your local branches, or even your working tree. This means that fetching can never trigger any kind of conflict.

Pulling on the other hand merges the remote branch into the local branch. That's right, **a pull is effectively a merge**! So, like any other merge, a pull can result in a merge conflict, and if it does, you resolve it exactly like you would any other merge conflict. If you need a refresher, [instalment 110](pbs110) is entirely dedicated to dealing with merge conflicts.

## Working as a Team

To get a team up and running you need to handle the both the practicalities of somehow hosting a shared repository, and, of coordinating its use so as to avoid chaos.

It might sound more daunting to get some kind of shared repo up and running, but that's definitely the easy part, it's the coordination that requires the challenging mix of people skills, logic, practicality, and flexibility!

### The Big Picture

The mental model when working as a team is very similar to the scenario of a lone developer with multiple computers we've used in recent instalments.

There will be one repository accessible to the entire team that is agreed to be the primary repo, i.e. the ultimate source of truth. Each developer will have a clone of that primary repo on each of their devices, and they'll do all their coding locally, pushing and pulling commits to and from the primary repo as they work.

### Hosting Options

When it comes to setting up a repository everyone can access there are lots of options, and they all have their plusses and minuses depending on your needs, skills, and resources. Some are easy to set up, some take a lot of work, some provide very basic functionality, some have more bells and whistles than you can shake a stick at, some are free, and some come with a very substantial bill indeed. Each option is a good fit for some team somewhere, and there are more options than I could possibly list. The sky is very much the limit!

With that caveat in mind, here are a few commonly used options:

1. A bare Git repo on a NAS everyone on the team has mounted on their local file system.
2. A bare Git repo on a computer/server everyone on the team has SSH access to.
3. A server running the [Community Edition of GitLab](https://about.gitlab.com/install/?version=ce)
4. A free or paid-for package on a cloud-hosted Git-as-a-Service offering, e.g.:
	* A *Free*, *Teams*, or *Enterprise* [GitHub Organization](https://github.com/pricing)
	* A *Free*, *Premium*, or *Ultimate* plan from [GitLab](https://about.gitlab.com/pricing/)
	* A *Basic* (first 5 users free) or *Basic + Test Plans*  [Azure DevOps](https://azure.microsoft.com/en-us/pricing/details/devops/azure-devops-services/) subscription (needs Office365)

All the cloud-hosted offerings give you much more than just plain Git. At the very least they all offer options for documenting your code, tracking issues/feature requests, and even running automations triggered by commits. Many also offer additional features like integrated basic websites, and advanced automation pipelines (CI/CD) for automatically testing and deploying code to staging and production environments.

Within corporate organisations the paid-for plans probably make the most sense. There's more likely to be a need for the more advanced features, and, dedicated support is a must for anything business-critical, and for many business, that very much includes their code!

But, for a group of friends working together on something, those high-end plans are total over-kill. The free offerings from all the major players should work just fine, though I am a particular fan of free GitHub organisations. This entire series, and its sibling series [Taming the Terminal](https://ttt.bartificer.net), are hosted in a free GitHub organisation ([Bartificer Creations](https://github.com/bartificer)).

### Getting your Team Organised

In my experience, for things to go well you need to agree a number of things **before** you start using a shared repo. Just getting started and then trying to figure things out later is a recipe for disaster, trust me!

Before you write a single line of code, all contributors need to be on the same page on **all** of these points at the very least:

1. **Coding style** — spaces or tabs? How many? Do brackets/braces get *cuddled*, where do the opening and closing braces go? And much much more. FWIW, my advice is to agree to use the official, or the generally accepted, style guide for each language you'll use.
	
	A so-called [code linting](https://en.wikipedia.org/wiki/Lint_(software)) tool like [ESLint](https://eslint.org) for JavaScript or [PerlCritic](https://en.wikipedia.org/wiki/Perl::Critic) for Perl can real help here. If you choose to use one of these tools, the config should stored in the repo so everyone's code editor is applying the same rules!
2. **Development paradigm** — will you be using the test-driven-development?  Or some other software engineering approach?
3. **Documentation strategy** — you need to agree on how your code will be documented. Ideally, stick to the standard approach for your language, or, failing that, one of the de-facto commonly used approaches. E.g. for Java use JDoc, for Perl use PerlDoc, for JavaScript pick one of the many JDoc clones out there like [ESDoc](https://esdoc.org/) or [document.js](https://documentation.js.org).
4. **Branching strategy** (see [instalment 107](pbs107))
5. **Commit Message Policy** — an agreed approach for writing meaningful commit messages. Rather than re-inventing the wheel, it's probably best to adopt a standard approach like [Conventional Commits](https://www.conventionalcommits.org/) as described in [instalment 109](pbs109).
6. **Versioning Policy** — an agreed version naming scheme, ideally a widely used standard of defacto-standard like [SemVer](https://semver.org) (also described in [instalment 109](pbs109))



Fetch often, consider pulling often too.

## Final Thoughts

TO DO