# PBS 124 of X â€” Chezmoi on Multiple Computers

We've finally arrived at the finale of our exploration of [Chezmoi](https://www.chezmoi.io/) â€” the point where we expand our horizon to start syncing our dot files across multiple computers, but in such a way that we take handle the inevitable small differences between computers elegantly. While we might well want 90% or more of our settings to be the same on all computers, that 10% difference can be oh so important, and it's how Chezmoi deals with that 10% that made me fall in love with it ðŸ™‚

TO UPDATE

## Matching Podcast Episode

TO DO

## Instalment Resources

TO UPDATE OR DELETED AS NEEDED

* The instalment ZIP file â€” [pbs125.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs125.zip).

## Chezmoi Git Recap

Chezmoi's cross-computer syncing is entirely built upon its use of Git as its underlying contents management system. In instalment X we learned how to create an empty remote Git repo and push our dot files out to it. That remote repo is the key to syncing across computers.

As we learned in instalment X. we can choose to configure Chezmoi to automatically commit our changes to Git and push them. This is obviously convenient, but it means you lose control over when the commits happen, and the commit messages are all auto-generated. I don't find that a good experience, so I manage my Git repository myself, choosing to only commit and push when changes have been tested and debugged, not on each edit.

You have four choices for interacting with the Chezmoi Git repo:

1. Use a GUI client (my preferred approach on desktop computers).
2. Use the `chezmoi git --` command (my preferred approach on headless computers/VMs).
3. Use the `chezmoi cd` command to start a new shell session inside the Chezmoi source directory and use the `git` command from there.
4. Change into the Chezmoi source directory in your current shell session with `cd $(chezmoi source-path)` and use the `git` command from there.

## Some Additional Useful Templating Functions

Before we go any further, there are a few additional text/template and sprig functions it would be useful to know about.

### Quoting Strings

When using templates to add contents to a data file, it's important the appropriate special characters get escaped. If you don't properly escape your data, you could end up corrupting your dot files, which is obviously not what we want to do ðŸ™‚

These functions are all available for use in pipelines. The following are the most relevant to us:

1.  `quote` â€” wrap the input in quotation marks and escape any quotation marks within the string.
2. `squote` â€” same as `quote` but uses *single quotes* AKA apostrophes.
3. `js` â€” convert the passed value to a valid JavaScript variable definition.
4. `toJson` â€” convert the passed value to a valid JSON string.
5. `toPrettyJason` â€” convert the passed value to nicely formatted JSON string.

### A Ternary Operator of Sorts (a Function actually)

We've already seen two sprig functions that are very useful when defining values in a template â€” we've seen how the `default` function can be used to define a single fall-back value, and how the `coalesce` function searches for the best value from multiple sources. Well, sprig provides a third related function â€” `ternary`. This is not quite the same as the ternary operator in JavaScript, but it is similar. 

Sprig's `ternary` function expects three arguments, the last of which is a boolean value. The first argument is the value to return if the last argument is `true`, and the second the value to return if the last argument is `false`.  The ordering might seem a little strange at first, but remember, with pipelining the output of the previous function is passed as the **last** argument to the next function, so this arrangement allows the output of some kind of test to be piped to the ternary function.

For example, the following reads the `SHELL` environment variable, checks it's Zsh, and then outputs an appropriate value:

```
When it comes to shells, I'm {{ env "SHELL" | eq "/bin/zsh" | ternary "hip" "a laggard" }}!
```
(Seriously, running Zsh is hip, I promise ðŸ˜‰)

TO DO â€” Any More We Need

## Chezmoi's Sync Model

The basic model is very simple â€” initialise Chezmoi on your first computer, add some dot files, commit them locally, create an empty remote repo, push your dot files to it, then on all your other computers, initialise Chezmoi by cloning the remote repo.

Once all the computers are initialised, changes are managed by pushing and pulling to and from the remote repo, and running `chezmoi apply` after each pull to push the synced changes live.

## Initialising Chezmoi from a Remote Git Repo

When working on a single computer we initialised Chezmoi with the simple command `chezmoi init`. Initialising from a remote Git repo is almost as simple â€” simply pass the repo's URL as an argument!

However, don't do it just yet, we can ensure we have a better experience by doing a little more preparation first.

## Handling Differences Across Machines

There is an entire section of [Chezmoi's How To page](https://www.chezmoi.io/docs/how-to/#manage-machine-to-machine-differences) dedicated to the many different options open to you for dealing with differences across computers. As with everything else in this series, we're not going to look at every possibility here, we're simply going to look at a few of the more commonly used options. If you need something more complex, check out the documentation ðŸ™‚

### Define a Chezmoi Config Template

One of Chezmoi's most powerful features is its ability to generate its own config file from a template. If a file exists at the root of the repo named `.chezmoi.json.tmpl`, then when you do a `chezmoi init`, that template will be used to build the config.

This gives you two very important capabilities â€” firstly, and most obviously, it allows you to have Chezmoi behave differently on different computers, but secondly, because you can define data in the config file, it allows you to customise data fields that change from computer to computer.

To add just a little more power, Chezmoi provides special templating functions that **only work when processing a config template** which allow you to prompt the user for input, specifically; `promptString`, `promptInt`, and `promptBool`. All three functions require a single-word variable name as their only argument.

#### Initialising a Config Template

If you already have a Chezmoi config, then you can use that as the basis for your template by copying it to the appropriate location with:

```
cp ~/.config/chezmoi/chezmoi.json $(chezmoi source-path)/.chezmoi.json.tmpl
```

Note that `$()` is way to use the output of one command as an argument to another in Bash or Zsh.

If you don't already have a config simply create a new file using your favourite text editor and save it in the root of your Chezmoi source directory as `.chezmoi.json.tmpl`.

#### Testing Your Config Template

It's easy to make mistakes when writing a template, so you can test your config template with the following useful command:

```
chezmoi execute-template < $(chezmoi source-path)/.chezmoi.json.tmpl
```

If you make use of any of the prompt functions you need to pass values for each of the named variables using the `--init` flag followed by the `--promptString`, `--promptInt`, and/or `--promptBool` flags. Each of these flags takes name-value pairs as values, e.g.:

```
chezmoi execute-template --init --promptString email=something@somewhe.re < $(chezmoi source-path)/.chezmoi.json.tmpl
```

The `--init` flag is important, it tells the `execute-template` sub-command to make the special init-only functions available.

#### Re-Building Your Config File from the Template

Assuming your repo has a config template, then it will be used when Chezmoi is first initialised on a computer. But, you can re-built it any time by simply running `chezmoi init` again (without any arguments).

TO DO â€” EXAMPLE

### Use Templates

TO DO

### Use Includes

TO DO

### Use the `.chezmoiignore` File

TO DO

## Final Thoughts

TO DO