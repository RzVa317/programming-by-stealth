# PBS 140 of X â€” UML Class Diagrams

At this stage we have all the coding tools needed to port the Crypt::HSXKPasswd Perl module to JavaScript figured out â€” we know we'll be building the library in the NodeJS environment, using JSDoc to document it, using Jest to test it, and using WebPack to package it for publication.

Before we can start writing actual code we need to capture the design we'll be implementing in a standard way. We'll be producing API documentation with JSDoc as an output, so we obviously can't use that as our guide when building the first version of the code. We need to capture the requirements for version 1.0 in a way that's clear, and useful to developers. The documentation for the current Perl implementation will be helpful, but Perl and JavaScript are quite different languages, so the first step will be to translate the API from a collection of Perl modules into a collection of class definitions that can then be implemented in JavaScript.

It would certainly be possible to capture those class definitions in English, but that would be a horrendous chore, and the resulting wall of text wouldn't even be easy to use when coding. We need a better representation for the design â€” we need a diagram! We don't just need any diagram though, we need a diagram that adheres to industry standards so it's instantly understandable by any software engineer. In other words, we need a UML class diagram!

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE

* The instalment ZIP file â€” [pbs139.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs139.zip)

## What Problem do UML Class Diagrams Solve?

The new XKPasswd API will be object oriented, so it will consist of a collection of JavaScript ES 6 classes. So, our design documents need to capture the classes that will be need, the relationships between those classes, and the attributes and functions those classes must provide.

The act of creating the diagram will surface any implementation details that are Perl-specific, and force me to make decisions on how to transform those into a JavaScript-compatible design.

Once the diagram has been created it will act as a map to guide the coding work. The diagram will make it easy to find the right starting place â€” the classes that don't depend on any other classes, and then to work through the dependencies in an order that will allow the code to be functional and testable every step of the way. The diagram will also act as a glanceable quick reference for the details of all functions and attributes that need to be added to the classes.

## What are UML Class Diagrams?

UML is the *Unified Modeling Language*, and the spec defines many different diagram types, not just the class diagrams we're interested in at the moment. The entire UML spec is designed to be language agnostic, so I like to think of UML diagrams as **pseudo-code in pictures**. Because the spec is language agnostic, it's very broad, covering all possible features in all possible languages. I doubt any single human is intimately familiar with the entire spec, it's entirely expected that you pick and choose the parts you need, and ignore the rest, which is exactly what we'll be doing in this instalment ðŸ™‚

We'll be limiting our exploration of UML to just class diagrams, and our explorations of class diagrams to just:

1. *Aggregation*, *Composition*, and *Inheritance* class relationships
2. The *Abstract* class annotation
3. Class *Members*, i.e. static and instance attributes and functions

## UML Class Diagrams

### The Basics

Each class is represented as a box with three vertically stacked segments:

1. The class name in bold and centred, and any class annotations
2. The list of instance and static attributes, with static attributes underlined
3. The list of instance and static functions, again, with static functions underlined

The relationships between classes are represented by arrows with differently shaped heads, and optional cardinalities on each end.

When building out an object oriented design, you generally start by creating empty boxes for all the classes you can think of, then you start defining the relationships between them, and then you start adding the detail into each class. So, let's structure our exploration in the same way.

### The *Inheritance* Relationship

The simplest relationship to understand is inheritance. In modern JavaScript, inheritance is implemented with the `extends` keyword, so if you have one class that extends another, you have an inheritance relationship.

Inheritance is used to import, well, inherit really, the functionality form one class into another, and then add more. The class being inherited from  is generally referred to as the *parent*, the class or classes that do the inheriting as the *clild class classes*.

In UML class diagrams, inheritance is represented by a solid line with a filled triangular arrow at the parent class. For example, both `Crossover` and `Sedan` extend the class `Car`:

DIAGRAM 1

The inheritance relationship is often referred to as the *is a* relationship. In this case, a crossover is a car, and a sedan is a car.

### Abstract Classes

LEFT OFF HERE!!!

### The *Aggregation* & *Composition* Class Relationships

TO DO

### Class Members (Attributes & Functions)

TO DO

## Final Thoughts

