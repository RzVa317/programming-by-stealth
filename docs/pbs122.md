# PBS 122 of X â€” Managing *Dot Files* with Chezmoi

TO DO

## Matching Podcast Episode

TO DO

## Reminder â€” Chezmoi Terminology

Chezmoi manages **targets** (files, folders and symlinks), saving their desired definitions in the **source state** and converting them to a **destination state** which gets applied to a **destination directory** (usually your home directory).

The source state is stored in a directory (`~/.local/share/chezmoi` by default) which is referred to as the **source directory**.

Not that when using the `chezmoi` command, targets are always specified by their path in the destination directory, e.g. `~/.gitconfig`, not by their path in the source directory.

We need to understand these terms to be able to understand the [Chezmoi Reference Manual](https://www.chezmoi.io/docs/reference/), but until we learn about more advanced features like templating, we can think of Chezmoi as simply a tool for syncing canonical versions of our dot files from a Git repo at`~/.local/share/chezmoi` to our home directory.

finally, remember that Chezmoi only alters files it has been explicitly instructed to **manage**, all other files in the destination directory (your home dir) are considered **unmanaged**.

## Managing Files (*Targets*)

If you have existing dot files that you'd like Chezmoi to start managing, simply add them to your source state with the `chezmoi add` command. As an example, let's add our Git config and global ignore files:

```
chezmoi add ~/.gitconfig ~/.gitignore_global
```

We can now see that Chezmoi is managing these two files:

```
bart-imac2018:~ bart% chezmoi managed
.gitconfig
.gitignore_global
bart-imac2018:~ bart%
```

## Peeking Under the Hood â€” the Chezmoi Source State

As we're already reminded ourselves, Chezmoi stores its source state in the source directory, and there's a bi-directional re-naming rule applied to all managed targets. We can use the `chezmoi source-path` command to see the path within the source directory for any managed target.

For example, we can see the path to the file in the source state that stores the canonical version of the target `~/.gitconfig` with:

```
bart-imac2018:~ bart% chezmoi source-path ~/.gitconfig 
/Users/bart/.local/share/chezmoi/dot_gitconfig
bart-imac2018:~ bart% 
```

We can also use this command to reveal the path to the source folder itself by running it without any arguments:

```
bart-imac2018:~ bart% chezmoi source-path             
/Users/bart/.local/share/chezmoi
bart-imac2018:~ bart% 
```

We can use the Bash/Zsh shell's back-tick operator to use the output of the above command as the argument to the `cd` command to actually change into the Chezmoi source directory (the `pwd` command shows the current path):

```
bart-imac2018:~ bart% pwd
/Users/bart
bart-imac2018:~ bart% cd `chezmoi source-path`
bart-imac2018:chezmoi bart% pwd
/Users/bart/.local/share/chezmoi
bart-imac2018:chezmoi bart%
```

Now that we're in here we can have a proper look around with the `ls` command:

```
bart-imac2018:chezmoi bart% ls -la
total 16
drwxr-xr-x  5 bart  staff  160  5 Aug 23:59 ./
drwxr-xr-x  3 bart  staff   96 23 Jul 10:03 ../
drwxr-xr-x  9 bart  staff  288  4 Aug 23:50 .git/
-rw-r--r--  1 bart  staff  431  5 Aug 23:59 dot_gitconfig
-rw-r--r--  1 bart  staff   10  5 Aug 23:59 dot_gitignore_global
bart-imac2018:chezmoi bart% 
```

Notice that we have our two re-named managed files, and a hidden `.git` folder, because Chezmoi initialises a git repo for us.

We chose to change into the Chezmoi folder using the `cd` command in conjunction with the `chezmoi source-path` command. There is a more direct route to almost the same outcome, but with one subtle difference.

The `chezmoi cd` command opens a new shell and changes to the source directory inside that shell:

```
chezmoi cd
```

At first glance nothing has changed, but you are now in a shell within a shell. The most obvious difference is that you have lost your history, hitting the up arrow will not show `chezmoi cd` like you would expect. You can also prove you are in a new shell by leaving it with the `exit` command. If you exit in your terminal windows's primary shell you'll be told the process has completed and be left with an unusable window, but if you're in a shell within a shell you'll simply return to the outer shell.

You can also prove you are in a new shell by showing the current process ID before and after the `chezmoi cd` and `exit` commands. Bash and Zsh use the environment variable named `$` to store the process ID. you access an environment variable by pre-fixing its name with the `$` symbol, so you access the process ID with `$$`. The easiest way to see the value of an environment variable is with the `echo` command, so to see your current process ID you can use `echo $$`. The following sequence proves `chezmoi cd` starts an entire new shell rather than just changing the directory of the current shell:

```
bart-imac2018:~ bart% echo $$   
61420
bart-imac2018:~ bart% chezmoi cd
bart-imac2018:chezmoi bart% echo $$
66669
bart-imac2018:chezmoi bart% exit
bart-imac2018:~ bart% echo $$   
61420
bart-imac2018:~ bart%
```
 
 I'm not really sure why Chezmoi's developer chose to do it this way, but he did, so I think it's important to explain why your terminal might behave differently to how you expect after using the `chezmoi cd` command.
 
## Managing the Chezmoi Git Repo

While Chezmoi sets you up with a Git repository, it doesn't take responsibility for managing it, that's your job. You decide when to commit, what way to describe your commits, when to branch, and what remotes to configure, if any.

When it comes to managing your Chezmoi repo you have three choices:

1. **Plain Git** â€” you can change into the source directory either with the `cd` command or with `chezmoi cd`, and then you can use the `git` cli just like you would in any other repo.
2. **Your Favourite Git GUI** â€” if you have a Git GUI you like using, simply open the Chezmoi source directory in that GUI and work away. (FWIW, this is my preferred approach.)
3. **The `chezmoi git` Command** â€” for convenience, `chezmoi` can act as a proxy to the `git` command. The big advantage of this approach is that you can run the command from any folder, but that convenience does come at a price. Both the `chezmoi` and `git` commands accept command line flags, so how does `chezmoi` know which flags it should act on, and which it should pass on to Git? Simple â€” all flags before the special `--` flag will be assumed to be for `chezmoi`, and all flags after will be passed to `git`. All arguments get passed to `git`, regardless of whether they are before or after the `--` flag.
   
   So, to simply see the status of the Chezmoi Git repo the command is very stright forward: `chezmoi git status`. But, to commit all changes with a commit message the command gets a little more complicated: `chezmoi git commit -- -am 'Some Git Commit Message'`.
   
## Editing a Managed File

Ideally, you should get into the habit of editing the source version of managed files rather than editing the target version, but, assuming you're not using templates, Chezmoi makes it easy to push changes from the target back to the source by simply re-adding the file with `chezmoi add`.

So, if you want to start off building good habits that will stand to you as you start to use more advanced features, get into the habit of the following workflow:

1. Edit the file in the source state
2. Apply the changes
3. Commit the changes to Git

### Editing a Target in the Source State

If you don't want to look under the hood, the correct way to edit a target in the source state is with the `chezmoi edit` command. This will open the target's matching file in the source directory for editing in an editor. By default Chezmoi first checks if there is a `$VISUAL` environment variable defined, and if there is, it uses its value as the editor, if not, it checks for a `$EDITOR` environment variable, and failing that, it uses `vi`. On my Mac Chezmoi defaulted to `vi`, which works fine for me, but confuses most regular humans ðŸ˜‰ You could try to learn `vi` (it's an optional extra at the end of [instalment 11 of Taming the Terminal](https://ttt.bartificer.net/book.html#ttt11)), but you probably want to get an editor you like.

If you're happy to use a terminal-based editor, but want something a little more human-friendly than `vi` you can use `nano` (or its proverbial daddy  `pico`). To do that, simply export an environment variable named `EDITOR` with the appropriate value in your terminal before running `chezmoi edit`, e.g. `export EDITOR=nano`.

If you're on a Mac you can also have Chezmoi open files with the built in TextEdit GUI editor by exporting an environment variable named `VISUAL` with the value `'open -e'`, i.e. `export VISUAL='open -e'`.

On the Mac you can use a similar approach to use any GUI editor you like by using the `open` command's `-a` flag to specify the desired app, e.g. to use Smultron the command would be:

```
export VISUAL='open -a /Applications/Smultron.app'
```

Note that if you're using Linux you should be able to easily install `nano` from your distribution's standard package manager, and you can set the path directly to your visual editor of choice.

Having to export your editor each time is a pain, but don't worry, there is a better way â€” we can configure our shell to export the variable for us. Let's do that as a worked example.

The dot file you should use to specify the environment variable export depends on your choice of shell. You can tell which shell you're using from the value of the `SHELL` environment variable, e.g.:

```
bart-imac2018:~ bart% echo $SHELL
/bin/zsh
bart-imac2018:~ bart%
```

As you can see, I'm using Zsh, but if I were using Bash the value would be `/bin/bash`.

If you're using Zsh you should export your environment variables in `~/.zshenv`, and if you're using Bash you should export them in `~/.bash_profile`. I'm going to use Zsh in the example below, but if you're using Bash, substitution `~/.bash_profile` for `~/.zshenv` in all the commands.

Note that Chezmoi can only manage file that exist, so we need to be sure there is a `~/.zshenv` (or `~/.bash_profile`) before we can add it, but there is a posibility you already have a copy of this file with important settings in it, so, we need to ensure it exists in a non-destructive way. The simplest approach is to append a comment to the end of the file with the `echo` command, e.g.:

```
echo '#boogers' >> ~/.zshenv
```

Once we're sure the file exists, we need to tell Chezmoi to manage it with the `chezmoi add` command:

```
chezmoi add ~/.zshenv
```

We can now edit it, being sure to export our favourite editor first (I went with `export VISUAL='open -e'` to use TextEdit):

```
chezmoi edit ~/.zshenv
```

I replaced the silly boogers comment with the following and then saved the file:

```
export VISUAL='open -e'
```

***Note** if you use TextEdit, be sure to add an empty line at the end of the file or you'll get very odd behaviour.*

At this point we have a difference between our source state, and our destination state, we can see that with the `chezmoi status` command:

```
bart-imac2018:~ bart% chezmoi status
 M .zshenv
bart-imac2018:~ bart%
```

This shows I have one modified target, `.zshenv`. I can see the details of the change with the `chezmoi diff` command:

```
bart-imac2018:~ bart% chezmoi diff ~/.zshenv 
diff --git a/.zshenv b/.zshenv
index e9df22b36675f90ff80d7ecf030f4b6e5410243a..333c2f85295158b06b95af45cf4d723f1f667ae6 100644
--- a/.zshenv
+++ b/.zshenv
@@ -1 +1 @@
-# boogers
+export VISUAL='open -e'
bart-imac2018:~ bart%
```

Note that while Chezmoi used Git to calculate and display the diff, this is **not** showing the difference between the last commit and the current state of the target in the source directory, **it's showing the diff between the target in the source and destination directories**.

The edit we have made is in Chezmoi's source state, but it has not yet been applied in the destination directory. We can prove this to ourselves by outputting the current contents of the file in our home dir:

```
bart-imac2018:~ bart% cat ~/.zshenv 
# boogers
bart-imac2018:~ bart%
```

### Applying the Updated Source State to the Destination Directory

We're now ready to apply our updated source state to the destination directory. The command to do that is `chezmoi apply`:

```
bart-imac2018:~ bart% chezmoi apply                    
bart-imac2018:~ bart%
```

This doesn't give any output if there are no errors, but our changes have been applied:

```
bart-imac2018:~ bart% cat ~/.zshenv                    
export VISUAL='open -e'
bart-imac2018:~ bart%
```

LEFT OFF HERE!!!

### Committing the Changes

## Final Thoughts

To a large extent this instalment has been a bit of a tease â€” we know why we want to manage our dot files, that Chezmoi is a good tool for doing that job, we've examined Chezmoi's world view, and we've even initialised Chezmoi, but we haven't actually managed any files yet!

That's where we'll start next time â€” using Chezmoi to manage dot files on a single computer. Next we'll take things up a notch and add a remote Git repo and a second computer into the mix, and then we'll finish up by looking at how we can use templates to generate different target states for each computer from the same source state.