# PBS 149 of X â€” POSIX Special Variables & Flags

TO DO

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE

* The instalment ZIP file â€” [pbs148.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs148.zip)


## PBS 148 Challenge Solution

The optional challenge at the end of the previous instalment was to update our  breakfast menu script to it can optionally accept an argument â€” a limit on the number of items you can order.

Here's my sample solution, which you'll find in the instalment ZIP as `pbs148-challengeSolution.sh`:

```bash
#!/usr/bin/env bash

# read the menu
declare -a menu
while read -r menuLine
do
    # skip comment lines
    echo "$menuLine" | egrep -q '^[ ]*#' && continue

    # skip empty lines
    echo "$menuLine" | egrep -q '^[ ]*$' && continue

    # store the menu item
    menu+=("$menuLine")
done <<<"$(cat $(dirname "$BASH_SOURCE")/menu.txt)"

# default to unlimited items, then check if there is a first argument
limit=''
if [[ -n $1 ]]
then
    # validate the argument
    if echo "$1" | egrep '^[1-9][0-9]*$'
    then
        limit=$1
    else
        echo "invalid argument '$1' - must be a whole number greater than 0"
        exit 2 # custom exit code for bad arg
    fi
fi

# create an empty array to hold the order
declare -a order

# present the menu, with a done option
if [[ -z $limit ]]
then
    echo 'Choose your breakfast (as many items as you like)'
else
    echo "Choose up to $limit breakfast items"
fi
select item in done "${menu[@]}"
do
    # skip invalid selections ($item is empty)
    [[ -z $item ]] && continue

    # exit if done
    [[ $item == done ]] && break

    # store and print the item
    order+=("$item")
    echo "Added $item to your order"

    # if we're limiting, check the limit
    if [[ -n $limit ]]
    then
        [[ ${#order[@]} -ge $limit ]] && break
    fi
done

# print the order
echo -e "\nYou ordered the following ${#order[@]} items:"
for item in "${order[@]}"
do
    echo "* $item"
done
```

This solution doesn't use anything we've not technically covered, but there are two related things I'd like to draw your attention to.

Firstly, I think this is the first time my examples have made use of the `-n` test for *not zero-length*, it's basically the inverse of `-z` which tests for a length of zero. I first use it to see if an optional first argument (`$1`) was passed:

```bash
if [[ -n $1 ]]
```

Secondly, I chose to use a blank limit to represent an absence of any limit. The reason is quite simple, it allows both `-z` and `-n` to be used to quickly test for the presence or absence of a limit, e.g.:

```bash
# if there's no limit
if [[ -z $limit ]]
then
    echo 'Choose your breakfast (as many items as you like)'
else
    echo "Choose up to $limit breakfast items"
fi

# â€¦

# if there is a limit
if [[ -n $limit ]]
then
    [[ ${#order[@]} -ge $limit ]] && break
fi
```

## Special POSIX Variables

Before we can move on to learning how to add traditional terminal-style *flags* to our own scripts, we need a more detailed understanding of how Bash handles arguments, and before we can do that, we need to formally introduce a concept we've already met informally â€” the special POSIX variables that are available in **all** [POSIX](https://en.wikipedia.org/wiki/POSIX) compliant shells, including Bash.

We've actually already seen some of these variables, but we've not mentioned that they're bigger than Bash, that they're actually part of the much more general POSIX standard. Here's a table of the most important special POSIX variables:

| POSIX Variable | Description |
|*---*|*---|
| `$?` | The exit code of the previously executed command |
| `$$` ðŸ†• | The process ID (PID) of the currently running script |
| `$!` ðŸ†• | The process ID (PID) of the most recently started background task (we're going to ignore this one) |
| `$0` ðŸ†• | The name of the currently running script |
| `$1` â€¦ `$9` | The positional arguments |
| `$#` ðŸ†• | The number of arguments passed  to the script |
| `$*` ðŸ†• | A pseudo-array of all the arguments concatenated, then split on spaces (details to follow) |
| `$@` ðŸ†• | A pseudo-array of all the arguments (details to follow) |

There are times it's helpful to know your own process ID, or the process ID of a background task you just started, so you will find plenty of examples on places like Stack Overflow that make use of `$$` & `$!`, but I want to focus on the three special variables that related to the script's arguments that we've not met before â€” `$#`, `$*`, and `$@`.

LEFT OFF HERE!!!

## Bash Arguments â€” A Deeper Look

TO DO

## Optional Arguments with `optarg`

TO DO

## Final Thoughts



### An Optional Extra Bonus Challenge

In the meantime, if you want some more Bash practice, update your solution to the challenge to TO DO.