# PBS 127 of X — Introducing NPM (and Node)

We're  going to start the second phase of this series by expanding our developer's toolbox. Our developer's toolbox is basically code to help us write code!

We could install all our developer tools globally on our systems, but that comes with some notable drawbacks:

1. You need admin access to a computer to install things system-wide
2. You can only have one vesion of a tool when you install it system-wide, but different projects might need different versions
3. If a tool gets a major update that requires some kind of tweak or change within your projects, you'll have to do them all at once.

So, it's much better to install developer tools locally, within a project. Each project gets its own copy of the tools at what ever version it wants, and no admin access is needed.

Manually managing local coppies of tools in each project would be a chore, but thankfully, we can use a tool to help us manage the rest of our tools!

For the first two milestones for Phase 2 our developer tools will all be JavaScript-based, so the ideal tool to manage them is a JavaScript package manager, and the obvious choice there is the *Node Package Manager*, or NPM.

## Matching Podcast Episode

TO DO

## What are Node & NPM?

### The NodeJS JavaScript Runtime

As you might infer from the name, the Node Package Manager is part of the Node JavaScript runtime, better known as [NodeJS](https://nodejs.org/). So far in this series we have run all of our JavaScript in the browser. The browser provides both the core JavaScript language, and the DOM, and, it comes with a very severe restriction — the browser confines JavaScript code inside a very restrictive sandbox. NodeJS is an entirely different environment for executing JavaScript. Like the browser NodeJS can execute core JavaScript, but there is no DOM in NodeJS, instead,  NodeJS provides its own set of APIs, and unlike the browser, NodeJS does not sandbox your JavaScript code. This means that code running in NodeJS is free to read and write files, to interact with processes, to receive incoming network connections, and even to create windows and run custom GUI code within them.

With NodeJS, JavaScript code can be used to write command line apps, to act as the back-end for a web server, or indeed to implement a server for any networked protocol, and even to power GUI apps. In short, NodeJS allow JavaScript to break free from the confines of the browser, and do pretty much anything!

NodeJS is free, open source, and cross-platform, so everyone can play along. While NodeJS is not a browser, it is very closely related to one very specific browser — Google's open source [Chromium](https://en.wikipedia.org/wiki/Chromium_(web_browser)). When Google set out to develop their own browser they needed to create a JavaScript runtime for the browser so it could support JavaScript. At the time one of the bottlenecks on then-modern websites was slow JavaScript execution. Google could have taken an existing open source JavaScript engine like [SpiderMonkey](https://en.wikipedia.org/wiki/SpiderMonkey), the JavaScript engine that powers Firefox, but they chose not to. Instead, Google wanted to start fresh so their JavaScript engine would be fast and efficient without the decade or so of technical debt SpiderMonkey had accumulated. They succeeded in developing a lightning-fast JavaScript engine, and they named it for one of the most iconic engines in the world — [V8](https://en.wikipedia.org/wiki/V8_(JavaScript_engine)).

While Google developed V8 for their browser, because it's open source, it's found quite a few other homes since it was released in 2008, including NodeJS.

### The Node Package Manager (NPM)

If all NodeJS did was run JavaScript outside the browser it would already be a darn useful tool, but it does a lot more than that — it elegantly solves the problem of sharing and reusing code without ending up in dependency hell. Before NodeJS JavaScript as a language was missing a critical feature — the ability to easily bundle code into self-contained sharable and reusable chunks. Or, to use the correct jargon — JavaScript didn't provide support for packages. The developers of NodeJS solved this problem very elegantly, having learned both what works and what doesn't from earlier packaging systems like Perl's *Comprehensive Perl Archive Network*, or [CPAN](https://en.wikipedia.org/wiki/CPAN). The end result is the *Node Package Manager*, or [NPM](https://en.wikipedia.org/wiki/Npm_(software)).

When you install NodeJS you get two commands — `node` which gives you a JavaScript shell, and `npm` for managing JavaScript packages.

## Why do we need NPM (or Node)?

The larger Node environment can do so much, it's very easy to get overwhelmed, so we're going to take a very different approach to the one we took with Git or Chezmoi recently. Rather than do a multi-instalment series-within-a-series, we're going to learn about the piece of the Node ecosystem as we need them.

### NPM for Dependency Management

Our first encounter with Node is going to be as a tool for automatically fetching open source JavaScript resources and pulling them into our project.

NPM supports two kinds of dependencies — traditional dependencies, and developer dependencies. *"The things my code needs to run"*, and *"the things I need to help me create and ship my code"*. If we look at the JavaScript modules we've already used, then jQuery, Bootstrap, Moment.js, and is.js are traditional dependencies. If I write a web app that uses jQuery, then my web app needs jQuery to function, or, to use the jargon, my web app depends on jQuery. Almost all the 3rd-party code we've used we've used in this way, but there are two exceptions — the testing framework QUnit is a dev dependency, as is the document generator JSDoc. QUnit helps us create code, but the code we create runs just fine without it. Our code does not depend on QUnit, but our development process does.

Our first milestone is to ship a JavaScript version of the exiting Crypt::HSXKPasswd Perl module. The first thing we'll be using NPM for is to manage our dev dependencies, specifically, to provide us with:

1. A code linter (ESLint)
2. A testing framework (TBD)
3. A documentation generator (probably document.js)

As we write the code we're likely to encounter the need to make use of some third party code to save us re-inventing the wheel. When that happens we'll use NPM to manage those regular dependencies.

When it comes time to ship the code we'll pick up another dev dependency, a so-called *bundler* or *packager*, and while that decision is a while off yet, I'm leaning towards WebPack.

### NPM for Developer Task Automation

Having developer tools is all good and well, but you need to actually *use* them! Remembering all the arguments you want to pass to your documentation generator each time you generate docs would be a pain in the proverbials. The same goes for executing our hopefully ever growing test suite.

NPM to the rescue yet again! We can use NPM to define and execute named tasks, so instead of having to remember all the arguments, we can simply tell NPM to generate our docs, or run our test with commands like `npm run docs` and `npm run test`. Finally, when it's time to publish our work, we'll define a build script we can invoke with `npm run build`.

### Node for Testing

To test a JavaScript module you need to run JavaScript. Previously we've used the browser to run our QUnit tests, but there's no need for all that overhead. We can use the Node JavaScript runtime to do all our tests from the command line. What ever test suite we choose to use, we'll be executing it from the command line using `npm run`, and it will be the NodeJS engine executing the code.

### NPM for Module Bundling and Publishing

When we arrive at our first milestone and have some code ready for publishing as a module for others to import into their code, we'll be using NPM to install and run a bundler, but we'll also be using NPM to publish our module to the public NPM repository. That will allow anyone to use our module in their code by simply running `npm install --save hsxkpasswd`!

### Node to Build a Command-line App

Finally, one of our long-term milestones is to replace the existing Perl-based `hsxkpassw` terminal command with a new JavaScript-powered one. When we do that, NodeJS will be the runtime for that command.

## Final Thoughts

TO DO
