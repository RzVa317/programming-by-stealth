# PBS 134 of X â€” Firming up our Foundations (2 of 2)

In [the previous instalment](./pbs133) we made a start on firming up some of our foundations in preparation for diving into the Jest testing framework. Between the two instalments we had six topics to cover, four of which were covered in the previous instalment:

1. Clearing up some confusion around the difference between `npm install` and `npm ci`. âœ…
2. Some guidance on which JSDoc tags to use when, especially when documenting plain objects. âœ…
3. A refresher on the different ways of defining functions, specifically function statements, function expressions, and arrow functions. âœ…
4. A reminder on how function chaining works (heavily used by Jest) âœ…
5. An introduction to the concept of functions that return functions (used by Jest)
6. An explanation of how getters can be used to construct short but powerful syntaxes that seem quite counterintuitive at first glance (heavily used by Jest)

That leaves us with two advanced uses of functions to explore in this instalment.

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE IF NEEDED

* The instalment ZIP file â€” [pbs134.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs134.zip).

## Functions that Return Functions

At this point it seems a good idea to remind ourselves that in JavaScript, everything is either a literal value, or reference to an object.

Booleans, numbers, and strings are literal values, though remember that modern versions of JavaScript automatically convert strings to instances of the `String` class when needed, hence code like the following being possible:

```js
console.log("waffles".toUpperCase())
```

Everything else is an object â€” plain objects are objects are instances of the class `Object`, arrays are instances of `Array`, regular expressions are instances of `RegExp`, exceptions are instances of the class `Error` or one of its sub-classes, and importantly for us today, functions (and classes) are instances of the class `Function`.

So, a function is an object, and functions take literal values or references to objects as inputs, and can optionally return a single value or reference to an object. We've already seen functions being passed to other functions as arguments, we refer to those as *callbacks*, what we've not looked at yet are functions that return functions.

### There's no Special Syntax

We've seen how to create anonymous functions, and we've seen how to return values from functions, so there's no new syntax needed, we've just never combined these pieces of knowledge in this way before.

As an example, let's create a function that creates functions that *make* (print) some food:

```js
/**
 * A function to generate functions that 'make' a specific food item.
 * 
 * @param {string} [foodItem='ðŸ¥ž'] - An emoji representing the food to be made by the generated function. Defaults to pancakes.
 * @returns {function} Returns a function that takes one argument, a number, and 'makes' that many items of food by logging the appropriate number of emoji to the console.
 */
function foodMakerMaker(foodItem='ðŸ¥ž'){
  if(typeof foodItem !== 'string') foodItem = 'ðŸ¥ž';
  return (n=1) => {
    if(!(String(n).match(/^\d+$/)) && n > 0) n = 1;
    console.log(foodItem.repeat(n));
  };
}
```

## An Unusual use of Getters

## Final Thoughts

TO DO