# PBS 134 of X â€” Firming up our Foundations (2 of 2)

In [the previous instalment](./pbs133) we made a start on firming up some of our foundations in preparation for diving into the Jest testing framework. Between the two instalments we had six topics to cover, four of which were covered in the previous instalment:

1. Clearing up some confusion around the difference between `npm install` and `npm ci`. âœ…
2. Some guidance on which JSDoc tags to use when, especially when documenting plain objects. âœ…
3. A refresher on the different ways of defining functions, specifically function statements, function expressions, and arrow functions. âœ…
4. A reminder on how function chaining works (heavily used by Jest) âœ…
6. An explanation of how getters can be used to construct short but powerful syntaxes that seem quite counterintuitive at first glance (heavily used by Jest)
7. An introduction to the concept of functions that return functions (used by Jest)

That leaves us with two advanced uses of functions to explore in this instalment.

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE IF NEEDED

* The instalment ZIP file â€” [pbs134.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs134.zip).

## An Interesting (ab)use of Getters

I searched far and wide for a name for the design pattern we'll be building up to, but I've drawn a blank. I'm simply going to refer to it as *self-referential function chaining in disguise*.

### Self Referencing Function Chains

We ended the previous instalment with a refresher on the concept of *function chaining* by looking at this example:

```js
(new Date()).toString().toLowerCase().replace(/[ ]/g, '-')
```

In this example the object being passed down the chain changed with each function call â€” the chain started with a new `Date` object, the first call returned a new string, the second call another new string, and the third call a third new string. This is function chaining at its most general.

There is however a very important special case, where each function returns a reference to the object it was called on. That means that as the chain progresses, it's always the same object being altered. jQuery makes heavy use of this pattern. Consider the following example:

```js
const mainHeader = $('<h1>').addClass('mainHeading').attr('id', 'main_heading');
```

The initial call to the `$()` function creates a new jQuery object representing a newly created `<h1>`  tag. This also means that it's the `.addClass()` function from the jQuery class that gets called on the object next, and that function adds a class, and then returns itself. This means that the `.attr()` function is called on the same object the `.addClass()` function was called on â€” the code creates and object and then mutates it in two ways before it gets saved to a variable named `mainHeader`.

Under the hood this kind of self-referential chaining is enabled by returning the special value `this`.

Let's see it in action with a very simplistic example.

First, let's create a class to represent a parrot:

```js
class Parrot{
  constructor(name='Parry'){
    this._name = name;
  }
  get name() { return this._name; }
  squawk(){
    console.log('caaaaw');
    return this;
  }
  talk(){
    console.log(`${this.name} wants a cracker`);
    return this;
  }
}
```

Notice both of our instance functions (`.squawk()` & `.talk()`) return `this`.

This class supports self-referential function chaining:

```js
const p = new Parrot('Polly');
p.squawk().talk().squawk();
// logs:
// ----
// caaaaw
// Polly wants a cracker
// caaaaw
```

Note that if your JavaScript console also writes returned values to the console then the final *caaaaw* will be followed by the value returned by the final call to the `.squawk()` function, i.e. and instance of the `Parrot` class with the name Polly.

In this very simplistic example our chainable functions didn't alter the object, but in the jQuery example they did.

### Self-referencing Function Chains in Disguise

We know that getters were added to JavaScript to provide a way adding logic around the fetching of an attribute value. This is often used to provide derived attribute values, for example a `Circle` class could store only a radius, but provide getters for a radius and a diameter, one returning the stored value, the other twice the stored value.

Regardless of what getters were designed to be used for, they are nothing more than functions that take no arguments and return a value! Getters can return *any* value, even `this`, so they can be used to create function chains that don't look like function chains!

Let's update our `Parrot` class to use getters for squawking and talking:

```js
class Parrot{
  constructor(name='Parry'){
    this._name = name;
  }
  get name() { return this._name; }
  get squawk(){
    console.log('caaaaw');
    return this;
  }
  get talk(){
    console.log(`${this.name} wants a cracker`);
    return this;
  }
}
```

Notice that the only change is the addition of the keyword `get` twice!

Now that our functions have donned a disguise, we call them as if we were accessing an attribute, but, they still return `this`, so they still chain, just without obvious function calling syntax:

```js
const q = new Parrot('yllop'); // Polly sorta-kinda mirrored
q.squawk.talk.squawk
// logs:
// -----
// caaaaw
// yllop wants a cracker
// caaaaw
```

Because both `.squawk` and `.talk` are getters that return `this`, the code above is equivalent to:

```js
const q = new Parrot('yllop');
q.squawk;
q.talk;
q.squawk;
```

This is a fun nerd trick, but it it useful?

### Using Self-referential Function Chains in Disguise for Nicer Syntax â€” A Worked Example

The reason this odd trick is starting to gain popularity is because it can be used to enable more human-friendly code. We've already seen this in action in the [is.js]() type checking library where you can do things like:

```js
is.not.string(x);
```

The `.not` is a function in disguise!

To see how it's done, let's create a class for joining arrays of strings into human-friendly lists, i.e., turn the array `['pancakes', 'waffles', 'popcorn']` into the string `pancakes, waffles & popcorn`. To add a little more spice, let's support specifying the final conjunction (the `&` in this example), and wrapping each array element with some kind of punctuation mark.

Before we look at how it's done, let's see the code in action.

LEFT OFF HERE!!!

## Functions that Return Functions

At this point it seems a good idea to remind ourselves that in JavaScript, everything is either a literal value, or reference to an object.

Booleans, numbers, and strings are literal values, though remember that modern versions of JavaScript automatically convert strings to instances of the `String` class when needed, hence code like the following being possible:

```js
console.log("waffles".toUpperCase())
```

Everything else is an object â€” plain objects are objects are instances of the class `Object`, arrays are instances of `Array`, regular expressions are instances of `RegExp`, exceptions are instances of the class `Error` or one of its sub-classes, and importantly for us today, functions (and classes) are instances of the class `Function`.

So, a function is an object, and functions take literal values or references to objects as inputs, and can optionally return a single value or reference to an object. We've already seen functions being passed to other functions as arguments, we refer to those as *callbacks*, what we've not looked at yet are functions that return functions.

### There's no Special Syntax

We've seen how to create anonymous functions, and we've seen how to return values from functions, so there's no new syntax needed, we've just never combined these pieces of knowledge in this way before.

As an example, let's create a function that creates functions that *make* (print) some food:

```js
/**
 * A function to generate functions that 'make' a specific food item.
 * 
 * @param {string} [foodItem='ðŸ¥ž'] - An emoji representing the food to be made by the generated function. Defaults to pancakes.
 * @returns {function} Returns a function that takes one argument, a number, and 'makes' that many items of food by logging the appropriate number of emoji to the console.
 */
function foodMakerMaker(foodItem='ðŸ¥ž'){
  if(typeof foodItem !== 'string') foodItem = 'ðŸ¥ž';
  return (n=1) => {
    if(!(String(n).match(/^\d+$/)) && n > 0) n = 1;
    console.log(foodItem.repeat(n));
  };
}
```

## An Unusual use of Getters

## Final Thoughts

TO DO