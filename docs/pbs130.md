# PBS 130 of X â€” Good Technical Documentation

It's all well and good to say that you write such good code that it's *effectively self documenting* (yes, you actually hear people say that), and sure, comments help make all code more understandable, but really, that's just not enough. Clear, well commented, code is easy to work at on a small scale â€” either on small projects, or within parts of larger projects â€”  but they can't help you with the bigger picture. As your codebase grows, you need a map!

Way back in the early days of this series, when we were just dipping our toes into the programming water I shared one of my favourite programming clichÃ©s â€” *comments are like sex, good comments are great, but any comments are better than none* ðŸ™‚

That may not even be really true for comments, but it's definitely not true for technical documentation. What's worse than no docs? Out of date or inaccurate docs! Codes doesn't become well documented organically â€” it requires a consciously designed process, and the discipline to stick to it. There simply is no proverbial free lunch to be had here â€” sorry!

However, like with lunches, good tools can really help. Just like It's a heck of a lot easier to cook to a well thought out plan in a well equipped kitchen that's been organised such that you have all the tools and ingredients to hand just as you need them, it's a heck of a lot easier to write useful documentation with the support of a good toolkit! That's where documentation generators come in.

## Matching Podcast Episode

TO DO

## Who's The Audience?

*Documentation* is a spectacularly broad word, it means so many different things in so many contexts. When I buy a new car I need to know how to turn on the de-mister â€” I don't care what size wrench the mechanic needs when replacing the rear left shock absorber! When I sign up for a mortgage I need to know the dates and amounts of the repayments, how I get apply for a payment break, and where I can access my current balance â€” I don't care what port the Oracle database server holding my data is listening on! I could go on, but you get the idea.

In this phase of the project we're creating an API for use by developers in their software. The whole point of releasing the module as open source is to encourage developers to re-used it in their projects. This is entirely analogous to our use of jQuery, MomentJS, Bootstrap, etc.. We've only succeeded in using those open source APIs because they have good technical documentation targeted at consumers of their code.

Are users of the released API our only audience in an open source project? No!

The people creating the API also need documentation, and that documentation needs to describe not just published classes/functions, but all the under-the-hood stuff that powers them. Even when you're working on a project on your own, you still need this kind of documentation â€” trust me, future you will thank current you for making the effort!

So, we have two different audiences we need to cater for:
1. Creators of our API
2. Users of our API

## What Do The Audiences Need?

Before any developer can use an API they need to understand the problem it solves, and the big-picture abstractions it's built around. However, it's not just users of the API that need a good understanding of the API's purpose and mode, people contributing code to the API need that even more!

Similarly, both sets of developers need a clear, technical description of the API itself â€” what classes exist, what functions do those classes provide, what do those functions return, and what arguments do they expect? Is the API configurable? If so, how? And, what configuration directives are supported, and what values are acceptable for each?

Users of an API will also benefit greatly from a quick-start guide, some simple examples, and a few practical use-cases.

Examples and use-cases can help contributors understand the API's philosophy better, but they're not as important to this audience. But, there are things contributors need that users don't â€” they need details of the classes, variables, and functions that power the module but are not exported as part of the public API, and they need practical documents like style guides, branching policies, and contributor agreements.

### What are our Goals?

Let's lean in a little and figure out what we documentation we want to deliver for the HSXKPasswd JavaScript port this phase of the series is working to deliver.

I want to deliver two sets of documentation â€” one for the public, and one for contributors. The developer documentation won't be separate, it will simply by the public documentation with extra detail inserted where needed.

#### The Public Documentation
1. A welcome page with the module's elevator pitch, a quick-start guide, links to the rest of the documentation, and a link to the GitHub page hosting the project.
2. A description of the problem the module aims to solve, how it solves it, and the math that underpins it all.
3. The API specification â€” everything the module exports, all the return types, arguments, etc..
4. A contributors guide that outlines:
	1. The contributor agreement.
	2. The project's branching policy.
	3. The project's coding style.
	4. A quick guide for getting a working development environment up and running and building and testing the code.

IMO it's a healthy sign when an open source project gives the public the tools they need to convert the code into a fully functional build. I've never actually built my own customised copy of Bootstrap, but I could, because their docs clearly explain the process.

#### The Developer Documentation

The developer docs will be identical to the public docs, but, the API specification will include all the internal variables, functions and classes as well as the public ones.

## Bart's Documentation Dogma

I've been coding for decades, and in that time I've utterly failed at documentation more times than I care to admit, but I've also learned a lot of hard lessons from those failures. The most important lesson I learned is that not documenting is a terrible idea, and secondarily to that, I've learned a few other more practical lessons too.

### Documentation is Source Code

I'm a firm believer that the only way to facilitate complete and accurate documentation is to write the documentation into the source code. In fact, the documentation for a function shouldn't just be in the same file as the function's definition â€” it should be right next to it, so both the docs and the function fit on screen at the same time without scrolling!

### Document First

When I need to write a new class or function, or even simply declare a variable, I start by writing the documentation describing the class, function, or variable, then I translate that documentation into code.

Actually, that's being overly simplistic â€” what I really do is write the first draft of the documentation, then I try implement that idea in code, realise there were 50 things I didn't think about, then tweak the docs, write more code, tweak the docs, write more code â€¦ I keep tweaking both the docs and the code until the docs describe what the code actually needs to do, and the code actually does it!

### Start Simple and Keep Iterating

When you document first, your first draft will inevitably be very vague, but that's fine. As long as you have an iterative mind-set you know you'll be re-visiting the docs and the code many many more times. As long as each piece of the docs gets better each time you revisit it, you're on the right track.

### Longer is not a Synonym for Better!
On a related note â€” better doc does not always mean longer docs! Sometimes more really is more, but particularly as a a function, class, or entire API matures, shorter, clearer descriptions are often much better than longer ones. To me, it's a sign that I'm on the right path when my descriptions become simpler instead of more complex.

To abuse an old clichÃ© goes â€” *I'm sorry I wrote you such long docs, I'm still working on shortening them* ðŸ˜‰

## Our Toolkit

### JSDoc

### ESLint

### VSCode