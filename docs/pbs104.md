# PBS 104 of X â€” Tracking Changes in Git

So far in this mini series we've looked at the larger landscape of version control, we've explained why we've chosen the distributed version control system Git for this series, and we've learned how to make our first Git repository and add some files to it.

In this instalment we'll take things one step further and learn how to manage changes to our files.

TO DO â€” might also look at ignoring files, depends on time!

PLAYER HERE

## Playing Along

If you're like to play along with the examples you'll need to download this instalment's ZIP file, extract the folder pbs104a, change into it in a terminal, and execute the following commands to initialise it as a git repository with all the files added:

```
cd pbs104a
git init
[ `git symbolic-ref --short HEAD` = 'master' ] && git checkout -b main
git add .
git commit -m "initial version"
```

The majority of those commands are straight from the previous instalment, but notice that the optional command for re-naming `master` to `main` as needed with older versions of `git` has been pre-fixed with some additional logic. Since this is Programming by Stealth rather than Taming the Terminal I won't go into detail of exactly how that command works, instead, I suggest you save it for future use, perhaps in your text expansion utility of choice.

Having said that, for anyone who's curious, the terminal command for conditionally re-naming `master` to `main` makes use of the following commands/concepts:

1. the [POSIX `test` command](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html)
2. the `git symbolic-ref` command (`man git-symbolic-ref`)
3. So-called [*Lazy Evaluation*](http://wresch.github.io/2014/04/24/bash-short-circuit-evaluation.html) to only execute  the `git checkout` command when the current branch is `master`. 

## Some House-Keeping for Mac Users â€” Globally Ignore `.DS_Store` Files

To avoid macOS's hidden `.DS_STORE` files getting in our way we need to configure git to globally ignore those files. We'll explain these commands in detail in a future instalment, but for now, we'll simply make the change without digging into the detail.

Firstly, if you've already a Git user and you have a global ignore file set up already, do not follow these instructions! Instead, edit your existing file and make sure it includes the line: `**/.DS_Store`

You can see if you have an existing global ignore file with the `git config` command we learned about in the previous instalment:

```
git config --global core.excludesfile || echo 'NONE'
```

This will either show the path to your excludes file or `NONE`.

To create a global excludes file that ignores all `.DS_Store` files everywhere simply run:

```
echo '**/.DS_Store' >> ~/.gitignore_global
git config --global core.excludesfile ~/.gitignore_global
```

You can verify that the change has taken effect by re-running `git config --global core.excludesfile || echo 'NONE'`.

## Staging & Committing A Simple Change

For once, the typo in the first sentence of `index.html` is not a mistake, I intentionally put it there so we could correct it ðŸ™‚

Open `README.md` in your favourite text editor and correct *'example **is** instalment'* to *'example **in** instalment'*.

Once the typo is fixed `git status` will show we have one un-staged change:

```
bart-imac2018:pbs104a bart% git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
bart-imac2018:pbs104a bart%
```

Git is again being helpful, and letting us know that we can add our change to the staging area in the same way entirely new files are staged, with the `git add` command. 

Go ahead and stage the change with:

```
git add README.md
```

If we run `git status` again we can see that our change has been successfully staged and is ready to be committed:

```
bart-imac2018:pbs104a bart% git status
On branch main
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   README.md

bart-imac2018:pbs104a bart%
```

Like we did last week, we can now commit our staged change, along with a sensible commit message, with a command like:

```
git commit -m 'Fixed silly typo in README'
```

## Staging & Committing Multiple Changes

Let's make a more substantial change to our wee project, let's edit our HTML file to use a local copy of Bootstrap 4.

This involves editing both adding new files (a `contrib` folder containing Bootstrap's CSS and license file), and editing our existing `index.html`.

To play along at home copy the contents of the folder `pbs104a-v2` into your repository, replacing `index.html` when asked.

Once you've updated the files, you can see all the un-staged changes with `git status`:

```
bart-imac2018:pbs104a bart% git status                            
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   index.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	contrib/

no changes added to commit (use "git add" and/or "git commit -a")
bart-imac2018:pbs104a bart% 
```

Before we do anything else, let's stage the new `contrib` folder:

```
git add contrib
```

Now, we know from `git status` that we have made changes to `index.html` but how do we see the actual changes we made?

## Seeing Changes with `git diff`

To see the un-staged changes to a file use the command `git diff PATH/TO/FILE`, for example, to see the changes to `index.html` use:

```
git diff index.html
```

This will show all the changes in a command line pager appropriate for your OS, on Linux/Unix/Mac that will probably be  either the `less` or `more` terminal commands. Basically, `diff` will behave like `man`, allowing you to navigate up and down with the arrow keys, and to exit the pager by pressing `q`.

If you'd prefer not to use a pager and simply have all the changes printed to the terminal directly, use the `--no-pager` flag:

```
git --no-pager diff index.html
```

The format of the output takes some getting used to. New and changed lines are shown pre-fixed with `+` symbols, and deleted and old versions of changed lines are shows pre-fixed with `-` symbols. A few lines of un-changed content are shown around the changed lines for context, and there's some metadata shown too.

Most Git users don't look at their changes on the command line, this is where Git GUIs really come into their own. Every Git GUI will allow you to see the changes to your files in a visual way. You may recognise some similarities to this terminal output though.