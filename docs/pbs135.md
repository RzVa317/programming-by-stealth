# PBS 135 of X — Introducing Jest (and re-Introducing Unit Testing)

Way back in [instalment 33](./pbs33) I introduced the concept of *unit testing*, and we put theory into practice using the open source testing framework [QUnit](http://qunitjs.com/).

While the fundamental concept of unit testing hasn't changed since then, JavaScript has, and so indeed have we — we now know a lot more about a lot more, and we have a heck of a lot more experience putting our knowledge to use!

Outside of this series I've fallen out of love with QUnit. In my day job I had been trying to practice what I preach, to write test cases together with code, and to test each part of a project as I built it up. I kept it up for a while, but QUnit just proved too much of a chore, and I stopped using it. On the one hand, I don't miss the drudgery of writing those horribly repetitive test cases, but on the other hand, I now remember why I wanted to learn unit testing in the first place. While I was unit testing I spent very little time chasing down regression bugs. I obviously still made mistakes, but my test suites would catch them before I even committed the code, let alone pushed it into production. Without that safety net I found myself spending a lot more time tracking down weird bugs, and yes, causing regressions. I guess those software engineers knew what they were doing after all!

I've been looking for a good reason to justify spending the time to find a better alternative to QUnit for some time now, and the re-platforming of the Crypt::HSXKPasswd Perl module to JavaScript is the perfect opportunity. I want this JavaScript API to be built on a solid foundation so the codebase can have a long and fruitful life. That's why the API will be built, from day one, using three important software engineering tools:

1. A good linter to spot common bugs, nip bad practice in the bud, and keep the code nice and consistent — hence inviting Helma onto the show to teach us all ESLint. ✅
2. A good documentation generator, because good documentation is written with the code, not afterwards. That's why I introduced JSDoc in recent instalments. ✅
3. A good testing suite, one that adds less friction to the process than QUnit did.


## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE

* The instalment ZIP file — [pbs134.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs134.zip).

## A Quick Unit Testing Refresher

TO DO

## Choosing a Testing Framework

I spent a long time dithering on which test suite to choose. Realistically, what ever suite we start the project with will be with the project for as long as it lasts, so best not choose poorly!

My criteria were simple:

1. Good support for modern JavaScript, i.e. classes and promises rather than prototypes and callbacks.
2. Native support for ES6 modules (that proved a much bigger hurdle than you might imagine).
3. A developer-friendly syntax that's short to write and easy to read and understand.
4. A project with a strong community behind it that's under active development.
5. A project that's respected by the broader developer community — no point in learning something niche, the hard-won skills won't transfer, and it will be much harder to find help online.

If native ES6 module support were not an absolute requirement there would be plenty of options to choose between, but just about all JavaScript testing frameworks are built around Node, and have yet to extend beyond Node's CommonJS package format to also support ES6 Modules.

In the end, there was only one choice — Jest.

## Final Thoughts

TO DO